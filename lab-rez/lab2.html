<!DocType html>
<html lang="ro">
<head>
  <title>Disciplina SO - Laborator #2 (suport online)</title>
  <link rel="stylesheet" type="text/css" href="../my_styles.css" />
    <meta name="description" content="Sisteme de operare - curs și laborator - suport electronic">
    <meta name="keywords"    content="Operating Systems, Sisteme de operare, Unix, Linux, FII Iași, infoiasi, Cristian Vidrașcu">
    <meta name="author"      content="Cristian Vidrașcu">
    <meta charset="utf-8"><!-- pentru diacritice -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<h2><font color="blue">Laborator #2 :</font> suport online &nbsp; ( Îndrumar de laborator )</h2>

<b>Sumar:</b>
<h3>I) <a href="#sec_1" class="button_href">Lucrul la linia de comandă în Linux, cu comenzi simple (partea a doua)</a></h3>
<h4>I.1) Recap: <a href="#sec_1a" class="button_href">Reamintirea unor cunoștințe dobândite în lecția practică despre comenzi simple</a></h4>
<h4>I.2) Exemplificări: <a href="#sec_1b" class="button_href">Exemple de utilizare a unor comenzi simple (exerciții rezolvate)</a></h4>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:5px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1">I) <span class="stil_sumar">Lucrul la linia de comandă în Linux, cu comenzi simple (partea a doua)</span> :</p>

<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a">I.1) <span class="stil_recap">Reamintirea unor cunoștințe dobândite în lecția practică despre comenzi simple</span> :</p>

<b>Informații despre comenzi simple pentru lucrul la linia de comandă în Linux:</b>
<button onclick="myToggle('lab2_recap')">Hide / Show the presentation</button>
<div id="lab2_recap" style="display:block;" class="stil_prezentare">
<p>
(Re)citiți prezentarea cu lecția practică despre comenzi de bază și sisteme de fișiere în Linux - partea a 2-a, disponibilă
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/P2_commands2_web-ro.pdf">aici</a>.
</p>
<p>
<font color="red">Recomandare:</font>
<button onclick="myToggle('lab2_recap_bib')">Show / Hide the recommendation</button>
<div id="lab2_recap_bib" class="stil_bibliografie_suplimentara">
Nu vă rezumați doar la consultarea prezentării PPT indicate  mai sus;
citiți și subcapitolele corespunzătoare din cartea recomandată pentru componenta practică:
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/command.pdf">Cap. 2, §2.1</a>
și <a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/filesys.pdf">Cap. 2, §2.2</a>.
<!--
<br><br>
<i>Notă</i>: o versiune mai veche a acestor materiale, în format HTML, este disponibilă spre consultare
<a target="_blank" href="http://students.info.uaic.ro/~so/labs/command.htm">aici</a>
și, respectiv, <a target="_blank" href="http://students.info.uaic.ro/~so/labs/filesys.htm">aici</a>.
-->
</div>
</p>
</div>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:3px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>

<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b">I.2) <span class="stil_ex_rezolvate">Exemple de utilizare a unor comenzi simple (exerciții rezolvate)</span></p>

<ol>

<li><!-- Problema: lab2_ex13-new ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Info user(s) #1]</span>
&nbsp; <b>Exemplificare vizualizarea informațiilor despre conturile de utilizatori de pe sistemul respectiv, folosind diverse comenzi</b>.
<br>
Să se scrie comanda care să ne indice informații despre un cont de utilizator de pe sistemul pe care lucrați, cum ar fi ID-ul numeric asociat, sau grupurile din care face parte.
</p>
<p><i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentațiile comenzilor <code>id</code> și <code>groups</code>, disponibile pe
  sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 id</code> și respectiv <code class="stil_cmdBash">man 1 groups</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/id.1.html">aici</a> și respectiv
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/groups.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex13')">Show / Hide the solution</button>

<div id="lab2_ex13" class="stil_rezolvare">
Conform celor discutate anterior (a se revedea laboratorul #1),
fișierul <tt>/etc/passwd</tt> conține informații despre utilizatorii sistemului, câte unul pe fiecare linie de text,
iar fișierul <tt>/etc/group</tt> conține informații despre grupurile de utilizatori ai sistemului, câte unul pe fiecare linie de text.
<br>
Prin urmare, pentru a obține (o parte din) informațiile solicitate, am putea să vizualizăm conținutul acestor fișiere,
cu comenzile specifice de vizualizare a fișierelor (a se revedea laboratorul #1).
<br>
<i>Explicație suplimentară</i>:
<button onclick="myToggle('lab2_ex13a')">Show / Hide the details</button>
<div id="lab2_ex13a" class="stil_hidden-text_level1">
Uneori, apartenența la anumite grupuri de utilizatori nu este trecuta în <tt>/etc/group</tt>, ci este administrată centralizat în cazul
rețelelor companiilor sau instituțiilor, folosind tehnologii precum servere <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> (pentru rețele UNIX/Linux)
sau <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> (pentru rețele Windows).</div>
<br>
<br>
Informații de genul celor solicitate în enunț, despre un cont de utilizator de pe sistemul pe care lucrați, mai pot fi obținute și cu comanda următoare:
<br>
prompt> <code class="stil_cmdBash"> id <i>username</i></code>
<br>
<br>
Doar lista grupurilor din care face parte un utilizator se mai poate obține și cu comanda:
<br>
prompt> <code class="stil_cmdBash"> groups <i>username</i></code>
</div>
</br></br>
</li>


<li><!-- Problema: lab2_ex14-new ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Info user(s) #2]</span>
&nbsp; <b>Exemplificare vizualizarea listei de utilizatori conectați la sistem, folosind diverse comenzi</b>.
<br>
Să se scrie comanda care să ne indice informații despre utilizatorii care au deschise sesiuni de lucru pe sistemul pe care lucrați.
</p>
<p>
<i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentațiile comenzilor <code>users</code>, <code>who</code>, <code>w</code> și <code>finger</code>, disponibile pe
  sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 users</code> , <code class="stil_cmdBash">man 1 who</code> ,
  <code class="stil_cmdBash">man 1 w</code> , <code class="stil_cmdBash">man 1 finger</code> și respectiv <code class="stil_cmdBash">man 1 last</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/users.1.html">aici</a>,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/who.1.html">aici</a>,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/w.1.html">aici</a> și respectiv
  <!-- Error: nu exista pagina <a target="_blank" href="https://man7.org/linux/man-pages/man1/finger.1.html">aici</a> -->
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/last.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex14')">Show / Hide the solutions</button>

<div id="lab2_ex14" class="stil_rezolvare">
<b>i)</b> O primă soluție este folosirea comenzii <b>users</b>, fără argumente:
<br>
prompt> <code class="stil_cmdBash"> users</code>
<br>
Ne va furniza lista numelor utilizatorilor ce sunt conectați la sistem, la momentul respectiv.
<br>Un exemplu de output al acestei comenzi:
<button onclick="myToggle('lab2_ex14_i')">Show / Hide the output</button>
<pre id="lab2_ex14_i" class="stil_output">
adrian.erhan alexandra.ursu alin.gavriliu andra.andrici andreea.dascal antonio.cranga cosmin.ciobotaru dragos.capsa ... ... ... popa.razvan serban.doncean so stefan.nistor
</pre>
<br>
<i>Notă</i>: lista poate conține duplicate (e.g., în caz că vreun utilizator are deschise mai multe sesiuni).

<br><br>
<b>ii)</b> O altă soluție este folosirea comenzii <b>who</b>, tot fără argumente:
<br>
prompt> <code class="stil_cmdBash"> who</code>
<br>
Ne va furniza lista username-urilor celor conectați la sistem, plus alte informații legate de aceștia.
<br>Un exemplu de output (ordonat implicit după coloana TTY) al acestei comenzi:
<button onclick="myToggle('lab2_ex14_ii')">Show / Hide the output</button>
<pre id="lab2_ex14_ii" class="stil_output">
ioan.samson pts/0        2021-02-26 11:51 (86.124.182.132)
irina.burada pts/1        2021-02-26 12:01 (79.112.255.165)
eduard.prozoreanu pts/2        2021-02-26 07:37 (82.77.79.11)
gheorghe.panoschi pts/3        2021-02-26 12:03 (92.86.185.70)
dragos.capsa pts/4        2021-02-26 12:03 (5.13.23.110)
andra.andrici pts/5        2021-02-26 13:10 (79.112.126.191)
adrian.erhan pts/6        2021-02-26 12:12 (188.138.192.80)
popa.razvan pts/7        2021-02-26 12:13 (79.112.53.90)
stefan.nistor pts/8        2021-02-26 12:16 (82.77.237.102)
.            .            .                .
.            .            .                .
.            .            .                .
maria.motoroiu pts/19       2021-02-26 12:51 (46.97.170.40)
andreea.dascal pts/22       2021-02-26 12:44 (46.55.84.182)
antonio.cranga pts/23       2021-02-26 12:51 (194.176.167.55)
gabriela.neculea pts/24       2021-02-26 09:32 (194.176.167.3)
so       pts/25       2021-02-26 12:51 (79.112.83.231)
</pre>
<br>
<i>Notă #1</i>: coloanele de informații afișate pot fi controlate prin opțiunile pe care le acceptă această comandă (a se vedea pagina: <code class="stil_cmdBash">man 1 who</code>).
<br>
<i>Notă #2</i>: lista poate conține duplicate (e.g., în caz că vreun utilizator are deschise mai multe sesiuni).

<br><br>
<b>iii)</b> O comandă "înrudită" cu who, este comanda <b>w</b>, pe care o putem apela (și) fără argumente:
<br>
prompt> <code class="stil_cmdBash"> w</code>
<br>
Ne va furniza lista username-urilor celor conectați la sistem, plus alte informații legate de aceștia, plus un header de identificare a coloanelor de informații.
<br>Un exemplu de output (ordonat implicit după coloana TTY) al acestei comenzi:
<button onclick="myToggle('lab2_ex14_iii')">Show / Hide the output</button>
<pre id="lab2_ex14_iii" class="stil_output">
 13:14:55 up 17 days, 11:41, 23 users,  load average: 0.05, 0.04, 0.02
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
ioan.sam pts/0    86.124.182.132   11:51    1:17   0.68s  0.68s -bash
irina.bu pts/1    79.112.255.165   12:01   50.00s  0.54s  0.54s -bash
eduard.p pts/2    82.77.79.11      07:37    3:34m  0.57s  0.57s -bash
gheorghe pts/3    92.86.185.70     12:03    7:18   0.48s  0.48s -bash
dragos.c pts/4    5.13.23.110      12:03    2:23   0.67s  0.67s -bash
andra.an pts/5    79.112.126.191   13:10   16.00s  0.45s  0.04s mcedit file1.txt
adrian.e pts/6    188.138.192.80   12:12   17:09   0.48s  0.48s -bash
popa.raz pts/7    79.112.53.90     12:13   41:17   0.39s  0.39s -bash
stefan.n pts/8    82.77.237.102    12:16   31:22   0.50s  0.50s -bash
.            .            .                .
.            .            .                .
.            .            .                .
maria.mo pts/19   46.97.170.40     12:51    3:46   0.44s  0.44s -bash
andreea. pts/22   46.55.84.182     12:44   25:24   0.40s  0.40s -bash
antonio. pts/23   194.176.167.55   12:51   42.00s  0.53s  0.53s -bash
gabriela pts/24   194.176.167.3    09:32   12:23   0.69s  0.05s sshd: gabriela.neculea [priv]
so       pts/25   79.112.83.231    12:51    1.00s  0.22s  0.01s w
</pre>
<br>
<i>Notă #1</i>: coloanele de informații afișate pot fi controlate prin opțiunile pe care le acceptă această comandă (a se vedea pagina: <code class="stil_cmdBash">man 1 w</code>).
<br>
<i>Notă #2</i>: prima coloană, ce conține username-urile, este limitată, implicit, la 8 caractere (astfel, username-urile mai lungi de 8 caractere vor apare trunchiate!).

<br><br>
<b>iv)</b> O a patra soluție este folosirea comenzii <b>finger</b>, apelată tot fără argumente:
<br>
prompt> <code class="stil_cmdBash"> finger</code>
<br>
Ne va furniza lista username-urilor celor conectați la sistem, plus alte informații legate de aceștia, plus un header de identificare a coloanelor de informații.
<br>Un exemplu de output (ordonat implicit după coloana Login) al acestei comenzi:
<button onclick="myToggle('lab2_ex14_iv')">Show / Hide the output</button>
<pre id="lab2_ex14_iv" class="stil_output">
Login             Name           Tty      Idle  Login Time   Office     Office Phone
adrian.erhan                     pts/6      17  Feb 26 12:12 (188.138.192.80)
alexandra.ursu                   pts/17     22  Feb 26 12:50 (79.112.34.200)
alin.gavriliu                    pts/11      1  Feb 26 13:07 (194.176.167.20)
andra.andrici                    pts/5          Feb 26 13:10 (79.112.126.191)
.                 .              .              .
.                 .              .              .
.                 .              .              .
george.fechita                   pts/16     12  Feb 26 12:41 (188.27.228.74)
gheorghe.balan    BALAN P. GHEO  pts/10     32  Feb 26 12:41 (79.112.81.63)
gheorghe.panoschi                pts/3       7  Feb 26 12:03 (92.86.185.70)
ioan.samson                      pts/0       1  Feb 26 11:51 (86.124.182.132)
irina.burada                     pts/1          Feb 26 12:01 (79.112.255.165)
.                 .              .              .
.                 .              .              .
.                 .              .              .
popa.razvan                      pts/7      41  Feb 26 12:13 (79.112.53.90)
serban.doncean                   pts/15      4  Feb 26 12:49 (92.85.186.87)
so                               pts/25         Feb 26 12:51 (79.112.83.231)
stefan.nistor                    pts/8      31  Feb 26 12:16 (82.77.237.102)
</pre>
<br>
<i>Notă #1</i>: coloanele de informații afișate pot fi controlate prin opțiunile pe care le acceptă această comandă (a se vedea pagina: <code class="stil_cmdBash">man 1 finger</code>).
<br>
<i>Notă #2</i>: lista poate conține duplicate (e.g., în caz că vreun utilizator are deschise mai multe sesiuni).

<br><br>
<b>v)</b> Dacă ne interesează și istoricul sesiunilor de lucru, nu doar cele active la momentul prezent,
putem folosi comanda <code>last</code>, ce extrage aceste informații dintr-un fișier log de sistem, <tt>/var/log/wtmp</tt>,
în care se stochează toate sesiunile și care este resetat periodic de către admininstratorul sistemului.
Spre exemplu, apelată fără argumente:
<br>
prompt> <code class="stil_cmdBash"> last</code>
<br>
comanda ne va furniza lista tuturor sesiunilor de lucru pe server, în ordine invers cronologică (din prezent și până la momentul ultimei resetări a log-ului).
<br>
Dacă ne interesează doar istoricul sesiunilor unui anumit utilizator, putem apela comanda cu numele acelui utilizator drept argument.
Spre exemplu, dacă introducem comanda:
<br>
prompt> <code class="stil_cmdBash"> last so</code>
<br>
atunci un exemplu posibil de output afișat de această comandă ar fi următorul:
<button onclick="myToggle('lab2_ex14_v')">Show / Hide the output</button>
<pre id="lab2_ex14_v" class="stil_output">
so       pts/23       79.112.83.231    Fri Feb 26 11:19   still logged in
so       pts/27       79.112.86.169    Thu Feb 25 12:14 - 13:37  (01:23)
so       pts/11       79.112.86.169    Thu Feb 25 10:17 - 11:52  (01:35)
so       pts/12       79.112.30.218    Wed Feb 24 17:29 - 20:07  (02:38)
so       pts/25       79.112.30.218    Wed Feb 24 10:10 - 13:41  (03:30)
.        .            .                .
.        .            .                .
.        .            .                .
so       pts/13       79.112.18.208    Wed Feb 17 10:13 - 12:08  (01:54)
so       pts/1        79.112.36.155    Tue Feb 16 11:32 - 11:41  (00:08)

wtmp begins Mon Feb  1 07:14:02 2021
</pre>
</div>
</br></br>
</li>


<li><!-- Problema: lab1_ex0.5-new ---------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Basic file operations #5]</span><!-- Operații de bază cu fișiere #5 -->
&nbsp; <b>Exemplificare vizualizare și modificare a informațiilor despre fișiere, folosind diverse comenzi</b>.
<br>
Vizualizați metadatele (i.e., proprietățile) asociate fișierului <tt>d1/15lines.txt</tt>, creat în laboratorul anterior
  (a se revedea exemplul <span class="stil_ref_ex">[Basic file operations #1]</span>, pct. iii) din lecția
  disponibilă <a href="suport_lab1.html#sec_1b">aici</a>),
  iar apoi modificați diverse metadate dintre cele asociate fișierului <tt>d1/15lines.txt</tt>.	
</p>
<p><i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentațiile comenzilor <code>chmod</code>, <code>chown</code> și <code>chgrp</code>, disponibile pe
  sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 chmod</code> , <code class="stil_cmdBash">man 1 chown</code> și respectiv <code class="stil_cmdBash">man 1 chgrp</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/chmod.1.html">aici</a>,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/chown.1.html">aici</a> și respectiv
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/chgrp.1.html">aici</a>.
</p>

<button onclick="myToggle('lab1_ex0-5a')">Show / Hide some examples</button>
<div id="lab1_ex0-5a" class="stil_rezolvare">
Mai întâi, consultăm valoarea actuală a metadatelor asociate fișierului <tt>d1/15lines.txt</tt>, creat anterior:
<pre class="stil_codBash">
  cd   # pentru reîntoarcerea în propriul director acasă (doar dacă este necesar)
  stat d1/15lines.txt
</pre>
Un exemplu posibil de rezultat afișat de comanda stat ar putea fi următorul:
<pre class="stil_output">
  File: ‘d1/15lines.txt’
  Size: 35              Blocks: 8          IO Block: 4096   regular file
Device: fd05h/64773d    Inode: 12692988    Links: 2
Access: (0644/-rw-r--r--)  Uid: ( 1019/vidrascu)   Gid: (  503/   profs)
Access: 2020-02-21 13:14:54.414890033 +0200
Modify: 2020-02-21 13:12:38.780513539 +0200
Change: 2020-02-21 13:14:03.775005209 +0200
Birth: -
</pre>

<p>
O parte dintre aceste metadate nu le putem noi modifica în mod direct, ci doar în mod indirect, spre exemplu:
<ul>
  <li>dacă adăugăm conținut suplimentar într-un fișier, sau "ștergem" din conținutul lui, atunci se va actualiza în mod corespunzător și câmpul Size (i.e., lungimea fișierului în octeți);</li>
  <li>dacă "mutăm" fișierul într-un director ce este stocat pe un alt disc, sau măcar altă partiție decât discul/partiția ce stochează directorul unde se afla inițial fișierul,
  atunci se vor actualiza în mod corespunzător și câmpurile Device și Inode;</li>
  <li>câmpul Links (i.e., numărul de link-uri hard pe care le are acel fișier): îl putem modifica indirect,
  folosind comenzile <code>ln</code> și <code>rm</code> (revedeți exemplele din primul laborator).
  Spre exemplu, executăm comanda:
<pre class="stil_codBash">
  cd   # pentru reîntoarcerea în propriul director acasă (doar dacă este necesar)
  rm d1/d2/hardlnk1  # Se va șterge acel alias creat anterior, și astfel valoarea câmpului Links va scădea de la 2 la 1.
</pre></li>
</ul>
</p>

<p>
O altă parte dintre aceste metadate le putem modifica noi după dorință, folosind comenzi specifice:
<ul>
  <li>câmpul File (i.e., numele fișierului): îl putem modifica folosind comanda <code>mv</code> (revedeți exemplele din primul laborator);</li>
  <li>primul câmp Acces (i.e., permisiunile de acces la fișier): îl putem modifica folosind comanda <code>chmod</code>.
  Exemplificare:
<pre class="stil_codBash">
  cd   # pentru reîntoarcerea în propriul director acasă (doar dacă este necesar)

  chmod ug+x d1/15lines.txt
       # Se adaugă (+) dreptul x pentru proprietar (u) și pentru colegii de grup ai proprietarului (g).
       # Toate celelalte 9-2=7 permisiuni rămân neschimbate!

  chmod o-r  d1/15lines.txt
       # Se elimină (-) dreptul r pentru restul lumii (o). Toate celelalte 9-1=8 permisiuni rămân neschimbate!

  chmod 741  d1/15lines.txt
       # Se modifică complet toate cele 9 permisiuni, în conformitate cu semnificația notației octale:
       #  741 = rwx(u) r--(g) --x(o) !
</pre></li>
  <li>câmpurile Uid (i.e., ID-ul proprietarului) și Gid (i.e., ID-ul grupului proprietar): le putem modifica folosind comenzile <code>chown</code> și <code>chgrp</code>;</li>
  <li>al doilea câmp Acces (i.e., <i>timestamp</i>-ul <i>last acces time</i> al acelui fișier) și câmpul Modify (i.e., <i>timestamp</i>-ul <i>last modify time</i> al acelui fișier):
  le putem modifica folosind comanda <code>touch</code>.</li>
</ul>
</p>
</div>
</br></br>
</li>


<li><!-- Problema: lab2_ex3 ---------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[sort #1]</span>
&nbsp; <b>Exemplificare sortarea conținutului unui fișier, folosind comanda sort</b>.
<br>
Să se scrie comanda care să sorteze descrescător liniile de text din fișierul <tt>/etc/passwd</tt>, iar rezultatul sortării să fie salvat în fișierul <tt>output.txt</tt>.
<br>
<small>(Indicație: <span class="stil_hint2">folosiți comanda sort cu cele două opțiuni corespunzătoare cerințelor din enunț.</span>)</small>
</p>
<p><i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentația comenzii <code>sort</code>,
  disponibilă pe sistemul Linux pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 sort</code> ,
  sau accesați o variantă online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/sort.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex3')">Show / Hide some possible solutions</button>

<div id="lab2_ex3" class="stil_rezolvare">
O primă soluție posibilă ar fi:
<pre class="stil_codBash">
sort -r /etc/passwd -o output.txt
</pre>
Iată și alte combinații posibile de specificare a parametrilor &nbsp; (a se revedea observația de la <span class="stil_ref_ex">Ex.[cut #1]</span> din laboratorul #1, i.e.
<button onclick="myToggle('lab2_ex3_obs')">Show / Hide that remark from lab #1</button> ) :
<p id="lab2_ex3_obs" class="stil_hidden-text_level1">
<big>Observație importantă:</big>
<br>
Astfel de combinații de specificare a opțiunilor și argumentelor se pot face și pentru exercițiile precedente, <!-- sau cel ce urmează mai jos,-->
precum și pentru exercițiile din laboratoarele următoare,
chiar dacă în exercițiile respective, ce sunt însoțite de rezolvări, nu am specificat (și nu voi specifica) explicit acest lucru în rezolvări!
<br>
Cu alte cuvinte, uneori am specificat (și voi specifica) doar câte una (sau câteva) dintre combinațiile posibile pentru rezolvarea
exercițiului respectiv, dar aceasta nu înseamnă că nu mai sunt și alte rezolvări posibile, echivalente cu cea (cele) specificate!
</p>

<pre class="stil_codBash">
sort /etc/passwd -r -o output.txt

sort /etc/passwd -o output.txt -r

sort -r -o output.txt /etc/passwd

..., etc.
</pre>
Dar NU și formele următoare de apel:
<pre class="stil_codBash">
sort /etc/passwd -o -r output.txt

sort -r -o /etc/passwd output.txt
</pre>
(<i>Explicație</i>: ultimele două comenzi vor sorta fișierul output.txt și vor încerca să salveze rezultatul în fișierul <tt>/etc/passwd</tt>,
dar vor eșua din lipsă de drepturi.)
<br>
<br>
Presupunând că sort nu ar fi avut opțiunea -o , o altă soluție, mai generală, ar fi să folosim redirectarea ieșirii normale standard:
<pre class="stil_codBash">
sort -r /etc/passwd > output.txt
</pre>
</div>
</br></br>
</li>


<li><!-- Problema: lab2_ex4 ---------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[sort #2]</span>
&nbsp; <b>Exemplificare sortarea conținutului unui fișier, folosind comanda sort</b>.
<br>
Să se scrie comanda care să sorteze crescător după UID liniile de text din fișierul <tt>/etc/passwd</tt>.
<br>
<small>(Indicație: <span class="stil_hint2">folosiți comanda sort cu trei opțiuni: opțiunea pentru sortare numerică,
opțiunea pentru sortare după cheia câmpul 3 și opțiunea pentru stabilirea separatorului dintre câmpuri.</span>)</small>
</p>

<button onclick="myToggle('lab2_ex4')">Show / Hide some possible solutions</button>

<div id="lab2_ex4" class="stil_rezolvare">
O primă soluție posibilă ar fi:
<pre class="stil_codBash">
sort -n -t: -k3 /etc/passwd
</pre>
Iată și alte combinații posibile de specificare a parametrilor &nbsp; (a se revedea observația de la <span class="stil_ref_ex">Ex.[cut #1]</span> din laboratorul #1) :
<pre class="stil_codBash">
sort /etc/passwd -t: -k3 -n

sort --numeric-sort /etc/passwd --key=3 -t :

..., etc.
</pre>
</div>
</br></br>
</li>


<li><!-- Problema: lab2_ex12-new ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[wc #1]</span>
&nbsp; <b>Exemplificare numărarea unităților de text din conținutul unui fișier, folosind comanda wc</b>.
<br>
Să se scrie comanda care să ne indice câte conturi de utilizatori și, respectiv, câte grupuri de utilizatori există pe sistemul pe care lucrați.
<br>
<small>(Indicație: <span class="stil_hint2">folosiți comanda wc aplicată celor două baze de date, ce conțin utilizatorii sistemului și, respectiv, grupurile de utilizatori.</span>)</small>
</p>
<p><i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentația comenzii <code>wc</code>, disponibilă pe sistemul Linux pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 wc</code> ,
  sau accesați o variantă online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/wc.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex12')">Show / Hide the solution</button>

<div id="lab2_ex12" class="stil_rezolvare">
Conform celor discutate anterior (a se vedea laboratorul #1), fișierul <tt>/etc/passwd</tt> conține informații despre utilizatorii sistemului, câte unul pe fiecare linie de text,
iar fișierul <tt>/etc/group</tt> conține informații despre grupurile de utilizatori ai sistemului, câte unul pe fiecare linie de text.
<br>
Prin urmare, este suficient să folosim comanda <code>wc</code> ca să afișăm numărul de linii pentru fiecare din cele două fișiere.
<br>
Studiind documentația comenzii <code>wc</code> (i.e., pagina <code class="stil_cmdBash">man 1 wc</code>), aflăm că opțiunea de care avem nevoie este <tt>-l</tt> și, prin urmare, rezolvarea problemei constă în următoarea comandă:
<pre class="stil_codBash">
wc -l /etc/passwd /etc/group 
</pre>

<i>Detalii suplimentare</i>:
<button onclick="myToggle('lab2_ex12a')">Show / Hide the details</button>
<div id="lab2_ex12a" class="stil_hidden-text_level1">
Comanda indicată mai sus afișează rezultatul corect (i.e., câte conturi de utilizatori și, respectiv, câte grupuri de utilizatori există pe sistemul pe care lucrați) numai dacă sistemul respectiv gestionează local informațiile despre conturile de utilizatori și, respectiv, grupuri de utilizatori  folosind maniera clasică (i.e., bazele de date locale <tt>/etc/passwd</tt> și, respectiv, <tt>/etc/group</tt>).
Altfel, dacă sistemul respectiv e parte dintr-o rețea (a unei instituții sau companii) în care gestiunea informațiilor despre conturile de utilizatori și, respectiv, grupuri de utilizatori se face într-o manieră centralizată (e.g., folosind tehnologii precum LDAP), atunci rezultatul obținut cu această comandă nu mai este corect.
<br><br>
<div class="stil_hidden-text_level2"> 
<i>Observație</i>: serverul de Linux pentru uzul studenților, cunoscut generic sub numele de serverul <tt>students</tt>
(cu numele DNS complet: <tt>students.info.uaic.ro</tt>), are un istoric de aprox. 3 decenii, timp în care a trecut prin mai multe reconstrucții hardware și reconfigurări software.
Astfel, în perioada mai recentă, informațiile despre conturile de utilizatori și, respectiv, grupuri de utilizatori au fost gestionate local pe serverul <tt>students</tt>, până în anul 2021, inclusiv.
Apoi (i.e., <i>as of February 2022</i>) serverul <tt>students</tt> a fost "reconstruit" de la zero și s-a trecut la gestiunea informațiilor despre conturile de utilizatori și, respectiv, grupuri de utilizatori într-o manieră centralizată (folosind software-ul specializat IPA).
Mai recent (i.e., <i>as of summer of 2023</i>), serverul <tt>students</tt> a devenit indisponibil (hardware-ul a fost scos din uz). Iar în prezent (i.e., <i>as of February 2024</i>) noul administrator de sistem lucrează la reconstrucția întregii infrastructuri de rețea și a serverelor din FII, inclusiv la configurarea hardware+software a unui nou server care să preia
rolul vechiului server <tt>students</tt>, însă deocamdată nu se poate anticipa când se va finaliza această reconstrucție...
</div>
<br><br>
Ca urmare, în prezent (i.e., ulterior anului 2021) nu mai putem afla câte conturi de utilizatori sunt pe serverul <tt>students</tt>, cu ideea de mai sus.
<br>
Însă, putem încerca altfel: am observat în laboratorul precedent că fiecare student are un director acasă cu calea absolută de forma: <tt>/home/fenrir/studs/<i>username</i>/</tt> .
Prin urmare, am putea număra câte subdirectoare sunt în directorul <tt>/home/fenrir/studs/</tt> pentru a vedea numărul (aproximativ) de conturi de studenți de pe server.
Iar această numărare o putem face cu următoarea comandă compusă:
<br>
prompt> <code class="stil_cmdBash"> ls -1 /home/fenrir/studs | wc -l</code>
<br>
Valoarea afișată a fost: 1235 , la momentul când am rulat-o pe server (în februarie 2022).
<!-- (între timp, este posibil să mai fi crescut acest număr, dacă s-au mai creat alte conturi noi după momentul respectiv).-->
</div> 

</div>
</br></br>
</li>


<li><!-- Problema: lab2_ex1 ---------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[find #1]</span>
&nbsp; <b>Exemplificare căutare de fișiere, folosind comanda find</b>.
<br>
Să se scrie comanda care să parcurgă recursiv directorul dat ca argument și să afișeze permisiunile tuturor fișierelor și subdirectoarelor întâlnite.
<br>
<small>(Indicație: <span class="stil_hint2">folosiți comanda find și cu acțiunea de apelare a comenzii stat, sau acțiunea echivalentă de afișare cu format.</span>)</small>
</p>
<p><i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentația comenzii <code>find</code>, disponibilă pe sistemul Linux
  pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 find</code> ,
  sau accesați o variantă online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/find.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex1')">Show / Hide some possible solutions</button>

<div id="lab2_ex1" class="stil_rezolvare">
O primă soluție ar fi cea bazată pe folosirea comenzii <code>find</code> cu acțiunea de afișare cu format, i.e. <tt>-printf</tt> :
<pre class="stil_codBash">
find <i>arg_director</i> -printf "%m : %p\n"
   # specificatorul %m : afișează permisiunile în octal

find <i>arg_director</i> -printf %M\ :\ %p\\n
   # specificatorul %M : afișează permisiunile în notație simbolică
</pre>
<i>Observație</i>: mai sus am scris două variante ale acestei soluții, una care afișează permisiunile în octal și
cealaltă care afișează permisiunile în notație simbolică (deoarece enunțul nu specifică explicit care dintre cele două formate să fie utilizat).
Mai mult, fiecare dintre cele două variante poate fi scrisă echivalent în mai multe moduri, în funcție de modalitatea în care alegem să protejăm
caracterele cu interpretare specială, i.e. spațiul și newline-ul, în cadrul cuvântului care descrie formatul de afișare
(în acest sens, observați protejarea prin ghilimele folosită în prima variantă, respectiv protejarea prin caracterul '\' folosită în a doua variantă).
<br>
<br>
O a doua soluție ar fi cea bazată pe folosirea comenzii <code>find</code> cu acțiunea generală -exec, pentru a apela comanda stat:
<pre class="stil_codBash">
find <i>arg_director</i> -exec stat --format="%a %n" \{} \;
   # specificatorul %a : afișează permisiunile în octal

find <i>arg_director</i> -exec stat -c "%A %n" \{} \;
   # specificatorul %A : afișează permisiunile în notație simbolică
</pre>
<i>Observație</i>: observațiile făcute mai sus la prima soluție rămân valabile și în cazul celei de a doua soluții.
În concluzie, acordați atenție sporită modului în care introduceți cuvântul care descrie formatul de afișare,
deoarece acesta nu trebuie să conțină spații neprotejate!
Aceasta deoarece doar primul cuvânt care urmează după <tt>-printf</tt> se va lua în considerare drept format de afișare pentru acțiunea <tt>-printf</tt> !
Și, similar, se va considera drept format de afișare doar primul cuvânt care urmează după opțiunea <tt>-c</tt> sau <tt>--format=</tt> , opțiune specificată la comanda <code>stat</code> de la acțiunea </tt>-exec</tt>.
<br>
<br>
<div class="stil_QandA"><i>Întrebare</i>:
chiar dacă ambele (perechi de) soluții de mai sus sunt corecte, i.e. "calculează" (afișează) ceea ce se cere în enunțul problemei date,
care dintre ele credeți că este mai performantă (d.p.d.v. al timpului de execuție și/sau consumului de resurse ale sistemului pentru execuția sa) ?
Comanda <code>find</code> care folosește acțiunea <tt>-printf</tt> sau comanda <code>find</code> care folosește acțiunea <tt>-exec</tt> ? 
</div>
<br>
O a treia soluție ar fi să folosim varianta optimizată a acțiunii <tt>-exec</tt>, utilizabilă în cazul acelor comenzi de procesare a fișierelor care permit specificarea mai multor nume de fișiere ca argumente în linia de apel a comenzii respective, nu doar a unui singur fișier.
Comanda <code>stat</code> permite acest lucru, ca urmare o putem invoca cu varianta optimizată a acțiunii <tt>-exec</tt>:
<pre class="stil_codBash">
find <i>arg_director</i> -exec stat --format="%a %n" \{} +
   # specificatorul %a : afișează permisiunile în octal

find <i>arg_director</i> -exec stat -c "%A %n" \{} +
   # specificatorul %A : afișează permisiunile în notație simbolică
</pre>
<i>Observație</i>: remarcați faptul că singura diferență sintactică între cele două forme ale acțiunii <tt>-exec</tt> este caracterul folosit pentru a indica unde se termină linia de comandă invocată prin <tt>-exec</tt>, și anume caracterul ';' versus caracterul '+'.
Semantic însă, conform documentației comenzii <code>find</code>, putem afla că diferența între cele două forme constă în modul în care se apelează comanda <code>stat</code>:
câte un apel al comenzii <code>stat</code> pentru <b>fiecare</b> fișier selectat de testele specificate la <code>find</code>,
versus un singur apel al comenzii <code>stat</code> pentru <b>toate</b> fișierele selectate de testele specificate la <code>find</code>.
</div>

<p class="stil_observatie_level0">
<b>Topici avansate</b> (<i>pentru studenții mai buni, pasionați de tehnologie, ce doresc să afle informații și despre alte subiecte suplimentare, în plus față de setul minimal de cunoștințe predat în cadrul disciplinei SO</i>) :
<br>
Pentru a găsi și înțelege răspunsul la întrebarea formulată în cadrul rezolvării exercițiului de mai sus,
vă recomand să citiți explicațiile suplimentare prezentate <a target="_blank" href="prg_perf/suport_lab2perf.html">aici</a>.
</p>
</li>


<li><!-- Problema: lab2_ex2 ---------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[find #2]</span>
&nbsp; <b>Exemplificare căutare de fișiere, folosind comanda find</b>.
<br>
Să se scrie comanda ce afișează pentru toate fișierele găsite în directorul dat ca argument în linia de comandă, parcurs recursiv,
fișiere ale căror nume încep sau se termină cu litera 'a', următoarele proprietăți:
numele fișierului, data ultimei modificări și dimensiunea fișierului în Kbytes.
<br>
<small>(Indicație: <span class="stil_hint2">folosiți comanda find și cu opțiunea de combinare alternativă a mai multor criterii de căutare după nume,
iar la partea de acțiuni cu opțiunea -printf cu parametrii adecvați.</span>)</small>
</p>

<button onclick="myToggle('lab2_ex2a')">Show / Hide some possible solutions</button>

<div id="lab2_ex2a" class="stil_rezolvare">
O soluție posibilă, ceva mai "lungă", ar fi:
<pre class="stil_cmdBash">
find <i>arg_director</i> -name "a*" -printf "%p : %t : %k KB\n" -or -name "*a" -printf "%p : %t : %k KB\n"
</pre>
Echivalent, o putem scrie mai "condensat", prin forțarea precedenței de evaluare a sub-expresiilor folosind paranteze:
<pre class="stil_cmdBash">
find <i>arg_director</i> \( -name "a*" -o -name "*a" \) -printf "%p : %t : %k KB\n"
</pre>
<div class="stil_hidden-text_level1">
<i>Explicații suplimentare</i>:
<ol>
  <li>Operatorul <tt>-o</tt> sau <tt>-or</tt> se folosește în expresia specificată la <code>find</code> pentru a combina două sub-expresii
  (fie că sunt teste, i.e. criterii de căutare, sau pot fi acțiuni sau opțiuni generale/poziționale) 
  prin operatorul logic disjunctiv (i.e., "SAU logic" : nu trebuie ca ambele subexpresii să fie adevărate simultan,
  ci doar cel puțin una dintre ele trebuie să fie adevărată).
  Mai mult, evaluarea se face de la stânga la dreapta în manieră scurt-circuitată (optimizată):
  dacă prima sub-expresie este adevărată, atunci a doua sub-expresie nu mai este evaluată, rezultatul disjuncției fiind deja cunoscut: 'adevărat'.</li>
  <li>Lipsa explicită a vreunui operator logic între oricare două dintre sub-expresii este interpretată drept operatorul logic conjunctiv (i.e., "ȘI logic"), notat sintactic prin <tt>-a</tt> sau <tt>-and</tt>.</li>
  <li>Sub-expresiile sunt evaluate de la stânga la dreapta, operatorii logici disjunctiv și conjunctiv având aceeași precedență.</li>
  <li>Dacă dorim să schimbăm ordinea de evaluare a sub-expresiilor, putem folosi paranteze pentru aceasta.
  Precum în exemplul de mai sus, unde am folosit paranteze pentru a grupa mai multe criterii de căutare, cărora să le asociem/specificăm o singură dată, în afara parantezelor, acțiunea de efectuat.</li>
  <li>Atenție la caracterele speciale <tt>* { } ; ( )</tt> ce trebuie protejate ca să fie citite ca atare de comanda <code>find</code> !!!
  Altfel, dacă sunt neprotejate, le interpretează interpretorul de comenzi <code>bash</code> înainte de a executa comanda <code>find</code>,
  conform semnificației speciale pe care o au (veți afla detalii despre această interpretare pe care o face interpretorul de comenzi în lecția următoare).
  <br><i>Notă suplimentară</i>: în cazul caracterului <tt>*</tt> , acesta va rămâne neschimbat în urma interpretării de către <i>bash</i>
  atunci și numai atunci când nu se poate identifica nici un fișier care să se potrivească cu șablonul în care apare folosit
  caracterul <tt>*</tt> !!!</li>
</ol>
</div>
<br>
În schimb, următoarea nu este o soluție corectă pentru problema dată:
<pre class="stil_codBash">
find <i>arg_director</i> -name "a*" -o -name "*a" -printf "%p : %t : %k KB\n"
</pre>
<i>Explicație</i>:
<button onclick="myToggle('lab2_ex2b')">Show / Hide the details</button>
<div id="lab2_ex2b" class="stil_hidden-text_level1">
Prin eliminarea parantezelor de la a doua soluție, evaluarea expresiei formată din cele trei subexpresii,
i.e. "<tt>-name ...</tt>"  SAU  "<tt>-name ...</tt>"  ȘI  "<tt>-printf ...</tt>" ,
se face în mod normal, de la stânga la dreapta, operatorii logici "SAU" și "ȘI" având aceeași precedență.
<br>
Ca urmare, pentru fișierele din subarborele parcurs de comanda <i>find</i> care satisfac primul test "<tt>-name ...</tt>" (i.e., a căror nume începe cu litera 'a'), rezultă că rezultatul expresiei este 'adevărat', fără a se mai evalua și ce urmează după operatorul "SAU".
Astfel, pentru fișierele a căror nume începe cu litera 'a' NU se va mai afișa nimic!
</div>
</div>
</li>


<li><!-- Problema: lab2_ex15-new ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Info running programs]</span>
&nbsp; <b>Exemplificare vizualizarea listei de programe ce rulează în sistem, folosind diverse comenzi</b>.
<br>
Să se scrie comanda care să ne indice informații despre programele executate pe sistemul pe care lucrați, inițiate fiind de către sistemul de operare și/sau de către utilizatorii ce sunt conectați la sistem.
</p>
<p>
<i>Recomandare</i>:
  mai întâi, pentru a înțelege exemplele de rezolvare de mai jos, (re)citiți documentațiile comenzilor <code>pstree</code>, <code>ps</code> și <code>top</code>, disponibile pe
  sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 pstree</code> , <code class="stil_cmdBash">man 1 ps</code> și respectiv <code class="stil_cmdBash">man 1 top</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/pstree.1.html">aici</a>,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/ps.1.html">aici</a> și respectiv
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/top.1.html">aici</a>.
</p>

<button onclick="myToggle('lab2_ex15')">Show / Hide the solutions</button>

<div id="lab2_ex15" class="stil_rezolvare">
<b>i)</b> O primă soluție este folosirea comenzii <b>pstree</b>, care ne oferă o reprezentare vizuală a arborelui ce surprinde relațiile de "rudenie" între diferitele programe ce rulează în sistem.
<br>Exemple de apelare a acestei comenzi:
<pre class="stil_codBash">
pstree
  # Se afișează arborele cu toate programele ce rulează în sistem, rădăcina sa fiind procesul init (cu PID-ul 1).
</pre>
<i>Notă #1</i>: fără a folosi alte argumente, arborele este "compactat", reprezentând programele doar prin numele lor, iar dacă există mai multe instanțe de execuție ale unui program, va apare o singură dată numele acelui program, prefixat de un factor ce indică numărul de instanțe.
<br>
<i>Notă #2</i>: studiați documentația (i.e., pagina: <code class="stil_cmdBash">man 1 pstree</code>) pentru a vedea ce opțiuni sunt disponibile pentru a configura informațiile afișate în acest arbore!

<pre class="stil_codBash">
pstree <i>PID</i>
  # Se afișează sub-arborele cu acele programe ce rulează în sistem, având ca rădăcină procesul cu PID-ul specificat.

pstree <i>username</i>
  # Se afișează sub-arborii cu acele programe ce rulează în sistem, având ca rădăcini programe rulate de utilizatorul specificat.
</pre>
<i>Notă</i>: putem avea 0, 1, sau mai mulți sub-arbori "deținuți" de un utilizator (în funcție de câte sesiuni de lucru are deschise în acel moment).

<br><br>
<b>ii)</b> O altă soluție este folosirea comenzii <b>ps</b>, care ne oferă informații variate despre diferitele programe ce rulează în sistem.
<br>Exemple de apelare a acestei comenzi:
<pre class="stil_codBash">
ps
  # Se afișează informații doar despre programele utilizatorului curent, ce rulează doar în sesiunea de lucru curentă.

ps u
  # Se afișează informații (într-un format mai bogat, ce conține, în prima coloană, username-ul sau UID-ul proprietarului acelui proces,
  # plus alte coloane suplimentare) despre programele utilizatorului curent, ce rulează în toate sesiunile de lucru pe care le are deschise.

ps x
  # Se afișează informații despre toate programele utilizatorului curent (i.e., din toate sesiunile de lucru deschise de acesta),
  # INCLUSIV acele programe care sunt neinteractive, i.e. nu au asociat un terminal de control (e.g., instanțele programului sshd).

ps a
  # Se afișează informații despre toate programele din sistem, nu doar cele ale utilizatorului curent.
</pre>

Putem avea și combinații de opțiuni (se vor combina efectele opțiunilor individuale), spre exemplu:
<pre class="stil_codBash">
ps ux
ps ax
ps aux  
</pre>

Comanda <code>ps</code> acceptă o mulțime de opțiuni:
<ul>
  <li>o primă categorie este reprezentată de acele opțiuni care configurează ce coloane de informații să se afișeze, despre procesele selectate (cum se face selecția? vezi următoarea categorie!);</li>
  <li>o a doua categorie cuprinde acele opțiuni ce selectează submulțimea de procese, dintre toate cele ce rulează pe sistem, despre
  care să se afișeze informațiile solicitate (i.e., cele configurate cu prima categorie de opțiuni!).</li>
</ul>

<p>
Studiați documentația (i.e., pagina: <code class="stil_cmdBash">man 1 ps</code>) pentru a vedea ce opțiuni sunt disponibile pentru a configura mulțimea de procese selectate și, respectiv, coloanele de informații afișate!
</p>
Spre exemplificare, iată câteva dintre opțiunile pentru selecția mulțimii de procese despre care se vor afișa informații:
<pre class="stil_codBash">
ps -C <i>cmd-list</i>
   # Selectează doar procesele ce sunt instanțe de execuție ale programelor/comenzilor enumerate (prin numele lor) în lista dată.

ps --ppid <i>pid-list</i>
   # Selectează doar procesele ce sunt copii ai programelor/comenzilor enumerate (prin PID-urile lor) în lista dată.

ps -U <i>user-list</i>
   # Selectează doar procesele ale căror proprietari reali sunt cei enumerați (prin username sau UID) în lista dată.

ps -u <i>user-list</i>
   # Selectează doar procesele ale căror proprietari efectivi sunt cei enumerați (prin username sau UID) în lista dată.

ps -L
   # Se afișează informații și despre thread-urile individuale ale programelor multithreaded !

..., etc.
</pre>

Iată și câteva dintre opțiunile pentru configurarea informațiilor ce se vor afișa despre procesele selectate:
<pre class="stil_codBash">
ps -f
   # Se afișează un format mai lung (i.e., cu mai multe coloane de informații) decât cel implicit.

ps -F
   # Se afișează un format și mai lung (i.e., cu și mai multe coloane de informații) decât cel implicit.

..., etc.
</pre>

Cea mai utilă este opțiunea <tt>--format</tt> sau <tt>-o</tt>, care ne permite să ne definim propriul format de afișare,
combinând după dorință diversele tipuri de informații disponibile.
Spre exemplu:
<pre class="stil_codBash">
ps -o pid,user,args
   # Se afișează 3 coloane de informații: PID-ul procesului, proprietarul procesului, respectiv linia de comandă (i.e., numele programului plus argumentele cu care a fost apelat).

ps -o pid,args --forrest
   # În coloana cu linia de comandă se folosește grafică ASCII pentru a reprezenta relațiile de "rudenie" între procese.
</pre>

<b>iii)</b> O altă soluție este folosirea comenzii <b>top</b>, care ne oferă informații variate despre diferitele programe ce rulează în sistem, într-o manieră interactivă:
în cadrul unei ferestre în mod text, se afișează informații ce se actualizează automat în timp real (similar cu utilitarul Task Manager din Windows).
<pre class="stil_codBash">
top
</pre>
Se afișează fereastra interactivă de care spuneam; cu tasta 'h' obțineți help despre tastele pe care le puteți folosi pentru a configura informațiile afișate, iar cu tasta 'q' ieșiți din acest program.
<br>
<i>Notă</i>: comanda <code>top</code> poate fi invocată și cu o serie de opțiuni, despre al căror efect puteți citi în documentație (i.e., pagina: <code class="stil_cmdBash">man 1 top</code>).

<br><br>
<b>iv)</b> O altă comandă amintită în prezentare este comanda <b>jobs</b>, care este o comandă internă și furnizează informații despre programele pornite în background de la prompterul interpretorului curent.
</br>
<i>Notă</i>: fiind internă, documentația despre această comandă o puteți accesa cu comanda: <code class="stil_cmdBash">help jobs</code> .
<br>
Alte două comenzi interne înrudite cu aceasta sunt comenzile <code>fg</code> și <code>bg</code>.
Pentru a afla la ce sunt utile acestea, consultați-le descrierile (documentația), accesibile astfel:
<code class="stil_cmdBash">help fg</code> și, respectiv, <code class="stil_cmdBash">help bg</code> .
</div>
</br></br>
</li>



<li><!-- Problema: lab2_ex16-new ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[System info]</span>
&nbsp; <b>Exemplificare vizualizare informații variate despre sistem, folosind diverse comenzi</b>.
<br>
Să se scrie comenzile care să vă ofere următoarele informații despre sistemul (calculatorul) pe care lucrați:
<ul>
<li><b>i)</b> data și ora curentă, precum și calendarul lunii (anului) curent;</li>
<li><b>ii)</b> de când (sau de cât timp) este pornit sistemul;</li>
<li><b>iii)</b> care este numele sistemului (i.e., numele prin care îl identificăm în rețea/Internet, pentru a ne conecta la el);</li>
<li><b>iv)</b> ce versiune de nucleu Linux și pentru ce arhitectură este instalat pe sistemul pe care lucrați;</li>
<li><b>v)</b> ce distribuție de Linux este instalată pe sistemul pe care lucrați.</li>
</ul>
</p>

<button onclick="myToggle('lab2_ex16')">Show / Hide the solutions</button>

<div id="lab2_ex16" class="stil_rezolvare">
<ul>
<li><b>i)</b>
<i>Recomandare</i>: mai întâi, pentru a înțelege exemplele de mai jos, (re)citiți documentațiile comenzilor <code>date</code> și <code>cal</code>,
  disponibile pe sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 date</code> și, respectiv,
  <code class="stil_cmdBash">man 1 cal</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/date.1.html">aici</a> și, respectiv,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/cal.1.html">aici</a>.
<br>
Data și ora curentă (a calculatorului pe care lucrăm) o putem afla folosind comanda <b>date</b>, fără argumente:
<br>
prompt> <code class="stil_cmdBash"> date</code>
<br>
Fără alte argumente, va afișa data și ora curentă, într-un format prestabilit (dependent de configurările legate de <i>language/region/time format</i> de pe sistemul respectiv).
<br>Exemple posibile de output ale acestei comenzi:
<button onclick="myToggle('lab2_ex16_i1')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_i1" class="stil_output">
Sun Feb 27 15:51:08 EET 2022

joi 7 martie 2024, 15:10:30 +0200
</pre>

<br>
Pentru a doua parte, calendarul lunii (anului) curent, vom folosi comenzile <b>cal</b> / <b>ncal</b>, cu diverse argumente:
<br>
prompt> <code class="stil_cmdBash"> cal</code>
<br>
Fără alte argumente, va afișa calendarul lunii curente, într-un format prestabilit
(ca și mai sus, formatul este dependent de configurările legate de <i>language/region/time format</i> de pe sistemul respectiv).
<br>Un exemplu de output al acestei comenzi:
<button onclick="myToggle('lab2_ex16_i2')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_i2" class="stil_output">
    February 2022
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 <u>22</u> 23 24 25 26
27 28
</pre>

prompt> <code class="stil_cmdBash"> cal -3 -m</code> &nbsp; # pe o distribuție CentOS 7
<br>
<u style="color:red;">sau</u>
<br>
prompt> <code class="stil_cmdBash"> ncal -3 -M</code> &nbsp; # pe o distribuție Debian-based (e.g. Ubuntu sau LinuxMint) 
<br>
Aceste apeluri vor afișa calendarul lunii curente, precum și a lunii anterioare și a celei viitoare.
Coloanele afișate vor începe cu ziua de luni, în loc de duminică.
<br>Un exemplu de output al acestor comenzi:
<button onclick="myToggle('lab2_ex16_i3')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_i3" class="stil_output">
    January 2022          February 2022          March 2022
Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su
                1  2      1  2  3  4  5  6      1  2  3  4  5  6
 3  4  5  6  7  8  9   7  8  9 10 11 12 13   7  8  9 10 11 12 13
10 11 12 13 14 15 16  14 15 16 17 18 19 20  14 15 16 17 18 19 20
17 18 19 20 21 22 23  21 22 23 24 25 26 <u>27</u>  21 22 23 24 25 26 27
24 25 26 27 28 29 30  28                    28 29 30 31
31
</pre>

prompt> <code class="stil_cmdBash"> cal -y -m</code> &nbsp; # pe o distribuție CentOS 7
<br>
<u style="color:red;">sau</u>
<br>
prompt> <code class="stil_cmdBash"> ncal -y -M</code> &nbsp; # pe o distribuție Debian-based (e.g. Ubuntu sau LinuxMint) 
<br>
Aceste apeluri vor afișa calendarul anului curent. Coloanele afișate vor începe cu ziua de luni, în loc de duminică.
<br>Un exemplu de output al acestor comenzi:
<button onclick="myToggle('lab2_ex16_i4')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_i4" class="stil_output">
                               2022

       January               February                 March
Mo Tu We Th Fr Sa Su   Mo Tu We Th Fr Sa Su   Mo Tu We Th Fr Sa Su
                1  2       1  2  3  4  5  6       1  2  3  4  5  6
 3  4  5  6  7  8  9    7  8  9 10 11 12 13    7  8  9 10 11 12 13
10 11 12 13 14 15 16   14 15 16 17 18 19 20   14 15 16 17 18 19 20
17 18 19 20 21 22 23   21 22 23 24 25 26 <u>27</u>   21 22 23 24 25 26 27
24 25 26 27 28 29 30   28                     28 29 30 31
31
        April                   May                   June
....................   ....................   .....................
....................   ....................   .....................

        July                  August                September
....................   ....................   .....................
....................   ....................   .....................

       October               November               December
Mo Tu We Th Fr Sa Su   Mo Tu We Th Fr Sa Su   Mo Tu We Th Fr Sa Su
                1  2       1  2  3  4  5  6             1  2  3  4
 3  4  5  6  7  8  9    7  8  9 10 11 12 13    5  6  7  8  9 10 11
10 11 12 13 14 15 16   14 15 16 17 18 19 20   12 13 14 15 16 17 18
17 18 19 20 21 22 23   21 22 23 24 25 26 27   19 20 21 22 23 24 25
24 25 26 27 28 29 30   28 29 30               26 27 28 29 30 31
31
</pre>

prompt> <code class="stil_cmdBash"> cal -y 2020</code>
<br>
Acest apel va afișa calendarul anului specificat. Coloanele afișate vor începe cu ziua de duminică (implicit, fără opțiunea -m / -M ca în exemplele de mai sus).
<br><br>
</li>

<li><b>ii)</b>
De când este pornit sistemul (i.e., calculatorul pe care lucrăm) putem afla folosind comanda <b>uptime</b>.
<br>
<i>Recomandare</i>: mai întâi, pentru a înțelege exemplele de mai jos, (re)citiți documentația comenzii <code>uptime</code>,
  disponibilă pe sistemul Linux pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 uptime</code> ,
  sau accesați varianta online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/uptime.1.html">aici</a>.
<br>
Exemple de apelare a acestei comenzi:
<br>
prompt> <code class="stil_cmdBash"> uptime -p</code>
<br>
Acest apel va afișa durata de timp scursă de când este pornit sistemul, într-un format inteligibil ușor pentru utilizatorii umani.
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>, în ziua de 27 februarie 2022:
<button onclick="myToggle('lab2_ex16_ii1')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_ii1" class="stil_output">
up 2 weeks, 4 days, 22 hours, 46 minutes
</pre>
(<i>Notă</i>: în urmă cu mulți ani, am observat și un uptime de peste 500 de zile... Ce vă spune această valoare?) 
<br>
prompt> <code class="stil_cmdBash"> uptime -s</code>
<br>
Acest apel va afișa momentul de timp (i.e., data+ora) la care a fost pornit sistemul, într-un format inteligibil ușor pentru utilizatorii umani.
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>, în ziua de 27 februarie 2022:
<button onclick="myToggle('lab2_ex16_ii2')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_ii2" class="stil_output">
2022-02-08 17:46:23
</pre>
prompt> <code class="stil_cmdBash"> uptime</code>
<br>
Acest apel va afișa ora curentă, durata de timp scursă de când este pornit sistemul, numărul de utilizatori umani logați pe sistem în momentul prezent, plus niște grade de încărcare ale sistemului calculate pe trei intervale recente de timp, specificate în documentația comenzii.
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_ii3')">Show / Hide the output</button>
<pre id="lab2_ex16_ii3" class="stil_output">
# în ziua de 27 februarie 2022:
 16:40:51 up 18 days, 22:54,  4 users,  load average: 0.06, 0.05, 0.05

# respectiv, în ziua de 25 ianuarie 2021:
 18:20:38 up 132 days,  9:04,  2 users,  load average: 93.09, 93.14, 93.11
</pre>
<br><br>
</li>

<li><b>iii)</b>
Care este numele sistemului (i.e., calculatorului pe care lucrăm) putem afla folosind
comenzile <b>hostname</b> și/sau <b>hostnamectl</b>, sau prin vizualizarea fișierelor de configurare amintite în prezentare.
<br>
<i>Recomandare</i>: mai întâi, pentru a înțelege exemplele de mai jos, (re)citiți documentațiile comenzilor <code>hostname</code> și <code>hostnamectl</code>,
  disponibile pe sistemul Linux pe care lucrați folosind comenzile <code class="stil_cmdBash">man 1 hostname</code> și, respectiv,
  <code class="stil_cmdBash">man 1 hostnamectl</code> ,
  sau accesați variantele online ale acestor documentații, disponibile
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/hostname.1.html">aici</a> și, respectiv,
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/hostnamectl.1.html">aici</a>.
<br>
Exemple de apelare a acestor comenzi, cu diverse argumente:
<br>
prompt> <code class="stil_cmdBash"> hostname -f</code>
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_iii1')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_iii1" class="stil_output">
students.info.uaic.ro
</pre>

prompt> <code class="stil_cmdBash"> hostname -A</code>
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_iii2')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_iii2" class="stil_output">
info-c-32.info.uaic.ro
</pre>

prompt> <code class="stil_cmdBash"> hostname -I</code>
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_iii3')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_iii3" class="stil_output">
85.122.23.32
</pre>

prompt> <code class="stil_cmdBash"> hostnamectl</code>
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>, în februarie 2022:
<button onclick="myToggle('lab2_ex16_iii4')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_iii4" class="stil_output">
   Static hostname: students.info.uaic.ro
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 680e0f6040d64a33b4719b81dad44be8
           Boot ID: d83a869540d04aa389ada36cf44830b1
    Virtualization: kvm
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-1160.42.2.el7.x86_64
      Architecture: x86-64
</pre>
De asemenea, puteți obține informații similare și/sau suplimentare
prin vizualizarea conținuturilor fișierelor de configurare amintite în prezentare:
<tt>/etc/hostname</tt> , <tt>/etc/machine-id</tt> , <tt>/etc/machine-info</tt> și, respectiv, <tt>/etc/hosts</tt>.
<!--
cat /etc/hostname
students.info.uaic.ro

cat /etc/machine-id
680e0f6040d64a33b4719b81dad44be8

cat /etc/machine-info
cat: /etc/machine-info: No such file or directory
-->
<br><br>
</li>

<li>
<b>iv)</b> Versiunea de nucleu Linux instalat pe sistemul pe care lucrăm, plus alte detalii (precum ar fi pentru ce arhitectură hardware este nucleul), putem afla folosind comanda <b>uname</b>.
<br>
<i>Recomandare</i>: mai întâi, pentru a înțelege exemplul de mai jos, (re)citiți documentația comenzii <code>uname</code>,
  disponibilă pe sistemul Linux pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 uname</code> ,
  sau accesați varianta online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/uname.1.html">aici</a>.
<br>
Exemplu de apelare a acestei comenzi:
<br>
prompt> <code class="stil_cmdBash"> uname -a</code>
<br>
Acest apel va afișa toate detaliile știute despre nucleul Linux instalat pe sistem.
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_iv1')">Show / Hide the output</button>
<pre id="lab2_ex16_iv1" class="stil_output">
# în ziua de 27 februarie 2022:
Linux students.info.uaic.ro 3.10.0-1160.42.2.el7.x86_64 #1 SMP Tue Sep 7 14:49:57 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

# respectiv, în ziua de 25 ianuarie 2021:
Linux fenrir 2.6.32-5-amd64 #1 SMP Tue May 13 16:34:35 UTC 2014 x86_64 GNU/Linux
</pre>
<br><br>
</li>

<li>
<b>v)</b> Detalii despre distribuția de Linux instalată pe sistemul pe care lucrăm putem afla în mai multe feluri
(unele fiind generale, altele fiind specifice doar pentru anumite distribuții):
putem încerca comanda <b>lsb_release</b>,
sau putem vizualiza conținutul fișierului de configurare amintit în prezentare: <tt>/etc/os-release</tt>.
<br>
<i>Recomandare</i>: mai întâi, pentru a înțelege exemplul de mai jos, (re)citiți documentația comenzii <code>lsb_release</code>,
  disponibilă pe sistemul Linux pe care lucrați folosind comanda <code class="stil_cmdBash">man 1 lsb_release</code>
  <!-- , sau accesați varianta online a acestei documentații, disponibilă
  <a target="_blank" href="https://man7.org/linux/man-pages/man1/lsb_release.1.html">aici</a> -- Eroare 404 -->.
<br>
Exemplu de apelare a acestei comenzi:
<br>
prompt> <code class="stil_cmdBash"> lsb_release -a</code>
<br>
Acest apel va afișa toate detaliile știute despre distribuția de Linux instalată pe sistem.
<br>Un exemplu de output al acestei comenzi, rulate pe serverul <tt>students</tt>:
<button onclick="myToggle('lab2_ex16_v1')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_v1" class="stil_output">
# în ziua de 27 februarie 2022:
-bash: lsb_release: command not found

# respectiv, în ziua de 25 ianuarie 2021:
No LSB modules are available.
Distributor ID:	Debian
Description:	Debian GNU/Linux 6.0.10 (squeeze)
Release:	6.0.10
Codename:	squeeze
</pre>

Precum se observă, în februarie 2022 comanda <b>lsb_release</b> nu mai era disponibilă în varianta (distribuția) curentă
de GNU/Linux instalată pe serverul <tt>students</tt> în acel moment.
Atunci mai putem încerca altceva: să vizualizăm informațiile din fișierul de configurare <tt>/etc/os-release</tt>.
<br>
prompt> <code class="stil_cmdBash"> cat /etc/os-release</code>
<br>Această comandă a afișat următorul output, când am rulat-o pe serverul <tt>students</tt> în februarie 2022:
<button onclick="myToggle('lab2_ex16_v2')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_v2" class="stil_output">
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
</pre>
<br>
<i>Observație</i>: există și comanda <code>distro-info</code>, specifică doar distribuțiilor derivate din Ubuntu sau Debian,
care oferă informații despre istoricul tuturor versiunilor de Ubuntu, respectiv Debian:
<br>
prompt> <code class="stil_cmdBash"> debian-distro-info --all --fullname</code>
<br>Această comandă a afișat următorul output, atunci când am rulat-o în februarie 2024:
<button onclick="myToggle('lab2_ex16_v3')">Show / Hide the output</button>
<br>
<pre id="lab2_ex16_v3" class="stil_output">
Debian 1.1 "Buzz"
Debian 1.2 "Rex"
Debian 1.3 "Bo"
Debian 2.0 "Hamm"
Debian 2.1 "Slink"
Debian 2.2 "Potato"
Debian 3.0 "Woody"
Debian 3.1 "Sarge"
Debian 4.0 "Etch"
Debian 5.0 "Lenny"
Debian 6.0 "Squeeze"
Debian 7 "Wheezy"
Debian 8 "Jessie"
Debian 9 "Stretch"
Debian 10 "Buster"
Debian 11 "Bullseye"
Debian 12 "Bookworm"
Debian 13 "Trixie"
Debian 14 "Forky"
Debian  "Sid"
Debian  "Experimental"</pre>
și, respectiv,
<br>
prompt> <code class="stil_cmdBash"> ubuntu-distro-info --all --fullname</code>
<br>Această comandă a afișat următorul output, atunci când am rulat-o în februarie 2024:
<button onclick="myToggle('lab2_ex16_v4')">Show / Hide the output</button>
<pre id="lab2_ex16_v4" class="stil_output">
Ubuntu 4.10 "Warty Warthog"     // prima versiune de Ubuntu, lansată în octombrie 2004
Ubuntu 5.04 "Hoary Hedgehog"
Ubuntu 5.10 "Breezy Badger"
Ubuntu 6.06 LTS "Dapper Drake"
Ubuntu 6.10 "Edgy Eft"
Ubuntu 7.04 "Feisty Fawn"
Ubuntu 7.10 "Gutsy Gibbon"
Ubuntu 8.04 LTS "Hardy Heron"
Ubuntu 8.10 "Intrepid Ibex"
Ubuntu 9.04 "Jaunty Jackalope"
Ubuntu 9.10 "Karmic Koala"
Ubuntu 10.04 LTS "Lucid Lynx"
Ubuntu 10.10 "Maverick Meerkat"
Ubuntu 11.04 "Natty Narwhal"
Ubuntu 11.10 "Oneiric Ocelot"
Ubuntu 12.04 LTS "Precise Pangolin"
Ubuntu 12.10 "Quantal Quetzal"
Ubuntu 13.04 "Raring Ringtail"
Ubuntu 13.10 "Saucy Salamander"
Ubuntu 14.04 LTS "Trusty Tahr"
Ubuntu 14.10 "Utopic Unicorn"
Ubuntu 15.04 "Vivid Vervet"
Ubuntu 15.10 "Wily Werewolf"
Ubuntu 16.04 LTS "Xenial Xerus"
Ubuntu 16.10 "Yakkety Yak"
Ubuntu 17.04 "Zesty Zapus"
Ubuntu 17.10 "Artful Aardvark"
Ubuntu 18.04 LTS "Bionic Beaver"
Ubuntu 18.10 "Cosmic Cuttlefish"
Ubuntu 19.04 "Disco Dingo"
Ubuntu 19.10 "Eoan Ermine"
Ubuntu 20.04 LTS "Focal Fossa"
Ubuntu 20.10 "Groovy Gorilla"
Ubuntu 21.04 "Hirsute Hippo"
Ubuntu 21.10 "Impish Indri"
Ubuntu 22.04 LTS "Jammy Jellyfish"
Ubuntu 22.10 "Kinetic Kudu"
Ubuntu 23.04 "Lunar Lobster"
Ubuntu 23.10 "Mantic Minotaur"
Ubuntu 24.04 LTS "Noble Numbat"     // viitoarea versiune LTS, ce va fi lansată în aprilie 2024
</pre>
</li>
</ul>

</div>
</li>

</ol>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<hr style="border-top:3px solid darkblue;">
<script src="../js/script_toggle.js"></script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</body>
</html>
