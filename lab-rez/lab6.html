<!DocType html>
<html lang="ro">
<head>
  <title>Disciplina SO - Laborator #6 (suport online)</title>
  <link rel="stylesheet" type="text/css" href="../my_styles.css" />
    <meta name="description" content="Sisteme de operare - curs și laborator - suport electronic">
    <meta name="keywords"    content="Operating Systems, Sisteme de operare, Unix, Linux, FII Iași, infoiasi, Cristian Vidrașcu">
    <meta name="author"      content="Cristian Vidrașcu">
    <meta charset="utf-8"><!-- pentru diacritice -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<script src="../js/script_include.js"></script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<h2><font color="blue">Laborator #6 :</font> suport online &nbsp; ( Îndrumar de laborator )</h2>

<b>Sumar:</b>
<h3>I) <a href="#sec_1" class="button_href">Programare: lucrul cu fișiere, folosind API-ul POSIX și biblioteca Standard I/O din C</a></h3>

<h4>I.1) Recap: <a href="#sec_1a" class="button_href">Reamintirea unor cunoștințe dobândite în lecția practică despre programare C pentru procesarea fișierelor</a></h4>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; Demo: <a href="#sec_1a0" class="button_href">Prezentarea unor programe demonstrative referite în lecția practică</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; <b>Topici avansate</b>: <a href="#sec_1a1" class="button_href">Prezentare informativă a unor cunoștințe ce se vor studia în cursuri teoretice ulterioare</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; Recap: <a href="#sec_1a2" class="button_href">Recapitularea unor cunoștințe dobândite anterior, despre reprezentările tipurilor de date</a></h5>

<h4>I.2) Exemplificări: <a href="#sec_1b" class="button_href">Exemple de programare a unor procesări de fișiere (exerciții rezolvate)</a></h4>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; a) <a href="#sec_1b1" class="button_href">Primul exemplu de program C (pentru ilustrarea <i>workflow</i>-ului de editare -- compilare -- execuție)</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; b) <a href="#sec_1b2" class="button_href">Exemple de programe C ce efectuează diverse prelucrări de fișiere</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; c) <a href="#sec_1b3" class="button_href">Exemple de programe C ce implementează comenzi uzuale din Linux/Unix</a></h5>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:5px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1">I) <span class="stil_sumar">Programare: lucrul cu fișiere, folosind API-ul POSIX și biblioteca Standard I/O din C</span> :</p>

<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a">I.1) <span class="stil_recap">Reamintirea unor cunoștințe dobândite în lecția practică despre programare C pentru procesarea fișierelor</span> :</p>

<b>Informații despre funcțiile din API-ul POSIX (și din biblioteca Standard I/O din C) pentru procesarea fișierelor în Linux:</b>
<button onclick="myToggle('lab6_recap')">Hide / Show the presentation</button>
<div id="lab6_recap" style="display:block;" class="stil_prezentare">
<p>
(Re)citiți prezentarea cu lecția practică despre programare C pentru procesarea fișierelor, disponibilă
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/P6_files_web-ro.pdf">aici</a>.
</p>
<p>
<font color="red">Recomandare:</font>
<button onclick="myToggle('lab6_recap_bib')">Show / Hide the recommendation</button>
<div id="lab6_recap_bib" class="stil_bibliografie_suplimentara">
Nu vă rezumați doar la consultarea prezentării PPT indicate  mai sus;
citiți și subcapitolul corespunzător din cartea recomandată pentru componenta practică:
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/file+lock.pdf">Cap. 3, §1.1-1.3</a>.
<br>
În plus, puteți citi o scurtă descriere informativă a compilatorului GNU pentru limbajul C/C++, în
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/compiler.pdf">preambulul
părții a doua</a> a cărții amintite mai sus.
<br><br>
<!--
<i>Notă</i>: o versiune mai veche a acestui material, în format HTML, este disponibilă spre consultare
<a target="_blank" href="http://students.info.uaic.ro/~so/labs/file.htm">aici</a>.
<br><br>
[ro]-->
Suplimentar, citiți capitolele 4, 5, 13, 15 și 18 din cartea <a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/TLPI1.pdf">[TLPI1]</a>.
<!--|| [en] <span lang="en">Also, you should read chapters 4, 5, 13, 15 and 18 from the book <a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/TLPI1.pdf">[TLPI1]</a></span>.-->
</div>
</p>
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a0" class="stil_ex_rezolvate" style="background-color: white;">Demo: Prezentarea unor programe demonstrative referite în lecția practică</p>

<ol>

<p>
a) În cele ce urmează voi relua programul demonstrativ ilustrat în lecția practică de mai sus,
cu explicații pentru fiecare dintre cele două versiuni ale acestuia prezentate în lecția practică.
Reamintesc, ideea programului este una foarte simplă:
copie conținutul unui fișier de intrare într-un fișier de ieșire, numele celor două fișiere fiindu-i transmise prin linia de comandă.
<br>
Copierea se realizează prin implementarea a două <i>sesiuni de lucru</i> cu cele două fișiere,
o sesiune cu operații de citire a fișierului de intrare și altă sesiune cu operații de scriere a fișierului de ieșire.
</p>

<li><!-- Program demonstrativ ilustrat în lecția practică ---------------------------------------------------------------->
<p><span class="stil_titlu_ex">[FirstDemo -- cp_POSIX]</span>
<br>Programul demonstrativ <tt class="stil_demo_filename">cp_POSIX.c</tt> ilustrează folosirea funcțiilor din API-ul POSIX
(i.e., <code class="stil_instrC">open()</code>, <code class="stil_instrC">read()</code>, <code class="stil_instrC">write()</code> ș.a.m.d.)
pentru implementarea celor două <i>sesiuni de lucru</i> cu cele două fișiere:
</p>
<button onclick="myToggle('lab6_demo1')">Show / Hide the 1st demo example</button>
<div id="lab6_demo1" class="stil_rezolvare">
<p>
1. Porniți editorul de texte preferat și scrieți codul de mai jos, apoi salvați-l într-un fișier cu numele <tt>cp_POSIX.c</tt>:
</p>

<button onclick="myToggle('lab6_demo1_src')">Show / Hide the source</button>
<pre id="lab6_demo1_src" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/cp_POSIX.c">See the code from <a target="_blank"
href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/cp_POSIX.c">here</a>.</div>
</pre>

<p>
<i>Observații</i>:
<br>i) constanta <tt class="stil_instrC">O_TRUNC</tt> de la apelul <code class="stil_instrC">open()</code>
are rolul de a trunchia la zero conținutul fișierului, păstrându-i nemodificate metadatele (atributele) asociate;
astfel, în cazul în care fișierul de ieșire deja există, conținutul său va fi resetat la zero,
fără a se cere confirmare de suprascriere.
Rolul folosirii acestei constante este acela de a obține o suprascriere "corectă", în sensul că altfel, fără folosirea ei,
dacă fișierul de intrare ar avea o lungime strict mai mică decât fișierul de ieșire deja existent, ar fi suprascrisă
doar partea de început din acesta, restul conținutului vechi din fișierul de ieșire rămânând nemodificat.
<br>ii) constanta <tt class="stil_instrC">O_CREAT</tt> de la apelul <code class="stil_instrC">open()</code> are rolul
de a crea fișierul de ieșire, în cazul în care acesta nu există deja,
iar constanta în octal <tt class="stil_instrC">0600</tt> de pe poziția a treia din apelul <code class="stil_instrC">open()</code>
are rolul de a specifica faptul că noul fișier ce se creează va avea următoarele permisiuni de acces:
"drepturi de citire și scriere doar pentru proprietar".
</p>

<p>
2. Compilați fișierul sursă pentru a obține programul executabil (<small>în formatul ELF64 pentru platforma Linux pe 64 biți</small>), cu următoarea comandă:
<br>prompt> <code class="stil_cmdBash"> gcc -Wall cp_POSIX.c -o cp_POSIX</code>
</p>

<p>
3. <b>Testarea programului</b>: lansați în execuție programul dându-i ca argumente două nume de fișiere:
i) primul va fi fișierul sursă (i.e., fișierul ce va fi copiat), ca urmare trebuie să specificați un nume de fișier existent;
ii) iar al doilea va fi fișierul destinație (i.e., fișierul în care va fi copiat conținutul fișierului sursă),
iar acesta va fi creat, în caz că specificați un nume de fișier inexistent,
respectiv va fi suprascris (fără a vă cere permisiunea de suprascriere!), în caz că specificați un nume de fișier existent.
<br>
prompt> <code class="stil_cmdBash"> ./cp_POSIX input_file output_file</code>
</p>
</div>
<br><br>
</li>

<li><!-- Program demonstrativ ilustrat în lecția practică ---------------------------------------------------------------->
<p><span class="stil_titlu_ex">[SecondDemo -- cp_stdio]</span>
<br>Programul demonstrativ <tt class="stil_demo_filename">cp_stdio.c</tt> ilustrează folosirea funcțiilor din biblioteca standard de C
(i.e., <code class="stil_instrC">fopen()</code>, <code class="stil_instrC">fread()</code>, <code class="stil_instrC">fwrite()</code> ș.a.m.d.)
pentru implementarea celor două <i>sesiuni de lucru</i> cu cele două fișiere:
</p>
<button onclick="myToggle('lab6_demo2')">Show / Hide the 2nd demo example</button>
<div id="lab6_demo2" class="stil_rezolvare">
<p>
1. Porniți editorul de texte preferat și scrieți codul de mai jos, apoi salvați-l într-un fișier cu numele <tt>cp_stdio.c</tt>:
</p>

<button onclick="myToggle('lab6_demo2_src')">Show / Hide the source</button>
<pre id="lab6_demo2_src" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/cp_stdio.c">See the code from <a target="_blank"
href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/cp_stdio.c">here</a>.</div>
</pre>

<p>
2. Compilați fișierul sursă pentru a obține programul executabil (<small>în formatul ELF64 pentru platforma Linux pe 64 biți</small>), cu următoarea comandă:
<br>prompt> <code class="stil_cmdBash"> gcc -Wall cp_stdio.c -o cp_stdio</code>
</p>

<p>
3. <b>Testarea programului</b>: lansați în execuție programul dându-i ca argumente două nume de fișiere:
i) primul va fi fișierul sursă (i.e., fișierul ce va fi copiat), ca urmare trebuie să specificați un nume de fișier existent;
ii) iar al doilea va fi fișierul destinație (i.e., fișierul în care va fi copiat conținutul fișierului sursă),
iar acesta va fi creat, în caz că specificați un nume de fișier inexistent,
respectiv va fi suprascris (fără a vă cere permisiunea de suprascriere!), în caz că specificați un nume de fișier existent.
<br>
prompt> <code class="stil_cmdBash"> ./cp_stdio input_file output_file</code>
</p>
</div>
<br><br>
</li>

<p>
b) Iar acum voi relua programul demonstrativ ilustrat în lecția practică de mai sus,
care citește doar o parte dintr-un fișier, de la anumite offset-uri (i.e., poziții în fișier) specificate în program.
<br>
Reamintesc faptul că, poziționarea la offsetul dorit se realizează prin apelul funcției <code class="stil_instrC">lseek()</code>, iar citirea unor informații de la poziția curentă din fișier se realizează prin apelul funcției <code class="stil_instrC">read()</code>.
</p>


<li><!-- Program demonstrativ ilustrat în lecția practică ---------------------------------------------------------------->
<p><span class="stil_titlu_ex">[ThirdDemo -- lseek_ex1.c]</span>
<br>Programul demonstrativ <tt class="stil_demo_filename">lseek_ex1.c</tt> ilustrează folosirea funcțiilor din API-ul POSIX
(i.e., <code class="stil_instrC">open()</code>, <code class="stil_instrC">lseek()</code>, <code class="stil_instrC">read()</code> ș.a.m.d.)
pentru implementarea <i>sesiunii de lucru</i> cu acel fișier conform descrierii din enunț:
</p>
<button onclick="myToggle('lab6_demo3')">Show / Hide the 3rd demo example</button>
<div id="lab6_demo3" class="stil_rezolvare">
<p>
1. Porniți editorul de texte preferat și scrieți codul de mai jos, apoi salvați-l într-un fișier cu numele <tt>lseek_ex1.c</tt>:
</p>

<button onclick="myToggle('lab6_demo3_src')">Show / Hide the source</button>
<pre id="lab6_demo3_src" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/lseek_ex1.c">See the code from <a target="_blank"
href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/lseek_ex1.c">here</a>.</div>
</pre>

<p>
<i style="color: red;">TODO</i>:
vă rămâne ca exercițiu să completați dvs. programul cu modificările necesare pentru a adăuga
tratarea cazurilor de eroare pentru apelurile <code class="stil_instrC">lseek()</code>+<code class="stil_instrC">read()</code>
folosite la a doua citire din fișier, într-o manieră similară cu tratarea cazurilor de eroare ilustrată în program pentru
apelurile <code class="stil_instrC">lseek()</code>+<code class="stil_instrC">read()</code> folosite la prima citire din fișier.
</p>

<p>
2. După ce faceți completarea indicată mai sus,
puteți compila fișierul sursă pentru a obține programul executabil (<small>în formatul ELF64 pentru platforma Linux pe 64 biți</small>), cu următoarea comandă:
<br>prompt> <code class="stil_cmdBash"> gcc -Wall lseek_ex1.c -o lseek_ex1</code>
</p>

<p>
3. <b>Testarea programului</b>: creați mai întâi un fișier de date cu numele specificat în enunț, și care să aibă ce conținut doriți dvs., dar minim 15 caractere/octeți (în caz contrar vor eșua apelurile de re-poziționare în fișier și/sau
apelurile de citire -- testați și această situație).
Spre exemplu, putem crea următorul conținut:
<br>
prompt> <code class="stil_cmdBash"> echo -n "0123456789ABCDEabcde01234" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex1 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
First read from file: ABCDE
Second read from file: abcde
Exit code: 0
</pre>
<br>
Pentru a testa și una dintre situațiile în care se va produce cel puțin o eroare, datorită cantității insuficiente de informație din fișier, putem crea spre exemplu următorul conținut:
<br>
prompt> <code class="stil_cmdBash"> echo -n "0123456789abc" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex1 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
1st read warning: insufficient information in file!
First read from file: abc
Second read from file: 34567
Exit code: 0
</pre>
<br>
Iată și o situație în care se va produce o altă eroare, datorită cantității insuficiente de informație din fișier:
<br>
prompt> <code class="stil_cmdBash"> echo -n "01234567" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex1 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
1st read warning: insufficient information in file!
First read from file:
Second read from file:
Exit code: 0
</pre>
<div class="stil_QandA">
<i>Întrebare</i>: ce credeți că s-a întâmplat la execuția programului pe acest conținut al fișierului de date?
<br>
<i>Răspuns</i>: primul apel <code class="stil_instrC">lseek()</code> nu a dat eroare,
ci a repoziționat cursorul la offsetul 10, adică dincolo de sfârșitul de fișier,
ceea ce corespunde comportamentului specificat în pagina de man a funcției <code class="stil_instrC">lseek()</code>.
Astfel, primul apel <code class="stil_instrC">read()</code> a returnat 0 (i.e., End-Of-File), necitind nimic.
<br>
În schimb, al doilea apel <code class="stil_instrC">lseek()</code> a dat eroare, dar în program lipsește partea de testare a erorii și ieșire din program...
Astfel execuția programului a continuat cu al doilea apel <code class="stil_instrC">read()</code>, care a încercat
să citească tot de la poziția curentă la care a rămas cursorul, i.e. la offsetul 10, adică dincolo de sfârșitul de fișier,
prin urmare și al doilea apel <code class="stil_instrC">read()</code> a returnat 0 (i.e., End-Of-File), necitind nimic.
</div>
</p>
</div>
<br><br>
</li>

<li><!-- Program demonstrativ ilustrat în lecția practică ---------------------------------------------------------------->
<p><span class="stil_titlu_ex">[ForthDemo -- lseek_ex2.c]</span>
<br>Programul demonstrativ <tt class="stil_demo_filename">lseek_ex2.c</tt> ilustrează folosirea funcțiilor din API-ul POSIX
(i.e., <code class="stil_instrC">open()</code>, <code class="stil_instrC">lseek()</code>, <code class="stil_instrC">read()</code> și <code class="stil_instrC">write()</code>, ș.a.m.d.)
pentru demonstrarea unei (supra)scrieri a informației dintr-un fișier la un anumit offset specificat,
urmată de citirea informației actualizate de la acel offset:
</p>
<button onclick="myToggle('lab6_demo4')">Show / Hide the 4th demo example</button>
<div id="lab6_demo4" class="stil_rezolvare">
<p>
1. Porniți editorul de texte preferat și scrieți codul de mai jos, apoi salvați-l într-un fișier cu numele <tt>lseek_ex2.c</tt>:
</p>

<button onclick="myToggle('lab6_demo4_src')">Show / Hide the source</button>
<pre id="lab6_demo4_src" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/lseek_ex2.c">See the code from <a target="_blank"
href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/lseek_ex2.c">here</a>.</div>
</pre>

<p>
<i style="color: red;">TODO</i>:
vă rămâne ca exercițiu să completați dvs. programul cu modificările necesare pentru a adăuga tratarea cazurilor de eroare
pentru apelurile <code class="stil_instrC">lseek()</code>+<code class="stil_instrC">write()</code> folosite
pentru suprascrierea informației din fișier la poziția 10, și respectiv pentru apelurile
<code class="stil_instrC">lseek()</code>+<code class="stil_instrC">read()</code>
folosite la a doua citire din fișier, într-o manieră similară cu tratarea cazurilor de eroare ilustrată în program pentru
apelurile <code class="stil_instrC">lseek()</code>+<code class="stil_instrC">read()</code> folosite la prima citire din fișier.
</p>

<p>
2. După ce faceți completarea indicată mai sus,
puteți compila fișierul sursă pentru a obține programul executabil (<small>în formatul ELF64 pentru platforma Linux pe 64 biți</small>), cu următoarea comandă:
<br>prompt> <code class="stil_cmdBash"> gcc -Wall lseek_ex2.c -o lseek_ex2</code>
</p>

<p>
3. <b>Testarea programului</b>: creați mai întâi un fișier de date cu numele specificat în enunț,
și care să aibă ce conținut doriți dvs., dar minim 15 caractere/octeți (în caz contrar vor eșua apelurile de re-poziționare
în fișier și/sau apelurile de citire / scriere -- testați și această situație).
Spre exemplu, putem crea următorul conținut:
<br>
prompt> <code class="stil_cmdBash"> echo -n "0123456789abcdeABCDE" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex2 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
First read from file: abcde
Second read from file: ZZZde
Exit code: 0
</pre>
Conținutul actualizat al fișierului îl putem vizualiza cu comanda:
<br>
prompt> <code class="stil_cmdBash"> cat datafile.txt</code>
<pre class="stil_output">
0123456789ZZZdeABCDE
</pre>
<br>
Pentru a testa și una dintre situațiile în care avem o cantitate insuficientă de informație în fișier,
putem crea spre exemplu următorul conținut:
<br>
prompt> <code class="stil_cmdBash"> echo -n "0123456789ab" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex2 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
1st read warning: insufficient information in file!
First read from file: ab
Second read from file: ZZZ
Exit code: 0
</pre>
Conținutul actualizat al fișierului îl putem vizualiza cu comanda:
<br>
prompt> <code class="stil_cmdBash"> cat datafile.txt</code>
<pre class="stil_output">
0123456789ZZZ
</pre>
În acest caz se observă faptul că lungimea fișierului a crescut (cu 1 octet).
<br><br>
Iată și o altă situație în care avem o cantitate insuficientă de informație în fișier:
<br>
prompt> <code class="stil_cmdBash"> echo -n "01234567" &gt; datafile.txt</code>
<br>
Iar apoi lansați în execuție programul, afișând și codul său de terminare:
<br>
prompt> <code class="stil_cmdBash"> ./lseek_ex2 ; echo "Exit code: $?"</code>
<br>
și observați outputul afișat pe ecran prin execuția programului:
<br>
<pre class="stil_output">
1st read warning: insufficient information in file!
First read from file:
Second read from file: ZZZ
Exit code: 0
</pre>
Conținutul actualizat al fișierului îl putem vizualiza cu comanda:
<br>
prompt> <code class="stil_cmdBash"> cat datafile.txt</code>
<pre class="stil_output">
01234567ZZZ
</pre>
Însă, dacă comparăm lungimile fișierului de date înainte și după execuția programului, putem constata faptul că
lungimea fișierului a crescut în acest caz cu 5 octeți.
<br>
Explicația este următoarea: la offseturile 8 și 9 în fișier s-au inserat "holes", adică octeți cu valoarea 0,
care nu sunt afișați de comanda <code class="stil_cmdBash">cat</code>.
Îi puteți vedea însă cu orice editor hexa, spre exemplu cu comanda
<code class="stil_cmdBash">mcview datafile.txt</code> și apăsați tasta F4 pentru a comuta în modul de afișare în hexadecimal.
<br>
Pentru detalii despre aceste "holes", în ce condiții "apar" ele într-un fișier, citiți cu atenție documentația
<a target="_blank" href="https://man7.org/linux/man-pages/man2/lseek.2.html">man 2 lseek</a>.
</p>
</div>
<br><br>
</li>

</ol>

</div>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a1"><b>Topici avansate</b>: <span class="stil_prolog">Prezentare informativă a unor cunoștințe ce se vor studia în cursuri teoretice ulterioare</span> :</p>

<h3>i) Despre <i>granularitatea informației</i> (i.e., unitatea de alocare și/sau de transfer) de la diferite nivele dintr-un sistem de calcul</h3>

<h3>ii) Despre <i>file-system cache</i>-ul gestionat de sistemul de operare</h3>

<h3>iii) Despre <i>cache</i>-urile gestionate de biblioteca standard I/O din C</h3>

<p>
Pentru a afla detalii despre toate aceste subiecte, consultați documentul disponibil <a target="_blank" href="suport_lab6_bib1_fs-cache.pdf">aici</a>.
</p>

<p class="stil_observatie_level0">
<b><i>Observație</i>:</b>
pentru <u>a putea scrie programe de aplicație nu doar corecte, ci și <b>eficiente/performante</b> (!)</u>, este necesar
să cunoașteți astfel de detalii legate de modul de execuție a apelurilor I/O și despre optimizările folosite atât la nivelul SO-ului,
cât și la nivelele superioare ale bibliotecilor și framework-urilor pe care le apelați în programele pe care le scrieți.
Și, bineînțeles, nu doar să le cunoașteți, ci și <u>să le aplicați în mod adecvat în programele pe care le scrieți</u>!
</p>

<br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a2">Recap: <span class="stil_prolog">Recapitularea unor cunoștințe dobândite anterior, despre reprezentările tipurilor de date</span> :</p>

<h3>i) Despre cele două reprezentări diferite, <i>binară</i> vs. <i>textuală</i>, ale diverselor tipuri de date</h3>

<h3>ii) Despre funcțiile de conversie între reprezentarea <i>binară</i> și cea <i>textuală</i> ale diverselor tipuri de date</h3>

<p>
Pentru a citi despre aceste subiecte, consultați documentul disponibil <a target="_blank" href="suport_lab6_bib2_stdio.pdf">aici</a>.
</p>


<br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:3px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b">I.2) <span class="stil_ex_rezolvate">Exemple de programare a unor procesări de fișiere (exerciții rezolvate)</span> :</p>

<ol>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b1">a) <span class="stil_ex_rezolvate">Primul exemplu de program C (pentru ilustrarea <i>workflow</i>-ului de editare -- compilare -- execuție)</span> :</p>


<li><!-- Problemă nouă, 2019  -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[FirstProgram--HelloWorld]</span>
<br>Primul program scris în limbajul C pentru platforma Linux: să se scrie un program C care afișează pe ecran textul "Hello world!".
<br>
<small>(Observație: <span class="stil_hint2">se vor ilustra comenzile de compilare a programului sursă și, apoi, de execuție a executabilului produs prin compilare.</span>)</small>
</p>

<button onclick="myToggle('lab7_ex0')">Show / Hide the solution</button>
<div id="lab7_ex0" class="stil_rezolvare">
1. Porniți editorul de text preferat și scrieți codul de mai jos, apoi salvați-l într-un fișier cu numele <tt>helloworld.c</tt>:
<pre class="stil_codC">
#include &lt;stdio.h>
#include &lt;unistd.h>

int main(int argc, char* argv[], char* env[])
{
   printf("Hello world!");
   sleep(3);  // O pauză de 3 secunde, pentru a observa "întârzierea" afișării textului pe ecran, introdusă de bufferul de la nivelul bibliotecii stdio!
   return 0;
}
</pre>

<p>2. Compilați fișierul sursă pentru a obține programul executabil (în formatul ELF64 pentru platforma Linux pe 64 biți), cu următoarea comandă:
<br>prompt> <code class="stil_cmdBash"> gcc -Wall helloworld.c -o helloworld</code>
</p>

<p>3. Lansați în execuție programul executabil obținut la pasul anterior:
<br>prompt> <code class="stil_cmdBash"> ./helloworld</code>
</p>

<p>
<i>Observație</i>: în eventualitatea că, la pasul 2. de mai sus, obțineți anumite mesaje de eroare din partea compilatorului,
este posibil să nu aveți instalat suportul complet pentru dezvoltarea de programe C.
<br>Motivația fiind aceea că fișierul iso pentru instalare furnizat de anumite distribuții de Linux (e.g. Linux Mint, versiuni mai vechi), este configurat implicit pentru
a instala un sistem ce va fi folosit cu rolul de utilizator obișnuit, nu de developer, și astfel sistemului Linux pe care vi l-ați instalat cu
ajutorul acelui iso, îi lipsește un pachet necesar pentru dezvoltarea de programe C.
<br>Pentru a remedia acest neajuns, va trebui sa instalați pachetul <tt>build-essential</tt>, lucru pe care îl puteți face de la linia de comandă, astfel:
<br>
prompt> <code class="stil_cmdBash"> sudo apt update ; sudo apt install build-essential</code>
<br>
<i>Notă</i>: această comandă e valabilă doar dacă distribuția de Linux pe care lucrați este derivată din Debian, e.g. Ubuntu sau Linux Mint.
Dacă folosiți vreun alt tip de distribuție, ce vă dă vreo eroare de genul "command apt not found...", înseamnă că acea distribuție folosește
un alt sistem de administrare a pachetelor (i.e., <i>package management system</i>) și ca atare va trebui să studiați documentația acelei distribuții
ca să aflați care este comanda (sau unealta grafică) pentru instalat pachete, ce este specifică pentru acea distribuție.
</p>

<p class="stil_hidden-text_level1_small-padding">
Suplimentar, puteți citi o scurtă descriere informativă a compilatorului GNU pentru limbajul C/C++, în
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/compiler.pdf">preambulul
părții a doua</a> a cărții recomandate pentru componenta practică.
</p>
</div>

<p class="stil_observatie_level0">
<i>Recomandare</i>: (re)vedeți exercițiul rezolvat
<a href="../bash/suport_lab5.html#sec_1b1"><span class="stil_ref_ex">[EditCompileRun]</span></a> din laboratorul precedent.
Vă recomand să folosiți scriptul respectiv, cu eventuale modificări după propria dorință, pentru a vă automatiza
activitatea de dezvoltare de programe C pe care o veți desfășura în cadrul laboratoarelor ce urmează.
</p>
<br>
</li>


<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b2">b) <span class="stil_ex_rezolvate">Exemple de programe C ce efectuează diverse prelucrări de fișiere</span> :</p>


<li><!-- Problema: lab7_ex1.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[AsciiStatistics]</span>
<br>Să se scrie un program C care primește de la linia de comandă numele unui fișier și afișează numărul total de apariții
pentru fiecare caracter ce apare în acel fișier.
<br>
<i>Cerință</i>: se vor utiliza apelurile de sistem din API-ul POSIX pentru accesarea fișierului.
<br>
<small>(Indicație: <span class="stil_hint2">printr-o singură parcurgere a fișierului, calculați de câte ori apare fiecare caracter ASCII posibil,
i.e. orice octet cuprins între 0 și 255.</span>)</small>
</p>

<button onclick="myToggle('lab7_ex1')">Show / Hide the solutions</button>
<div id="lab7_ex1" class="stil_rezolvare">
<p>
<b>1)</b> Prima soluție: <tt class="stil_demo_filename">AsciiStatistics_v1.c</tt> -- un program în care folosim apelurile de sistem
POSIX (i.e., <code class="stil_instrC">open()</code>, <code class="stil_instrC">read()</code>, ș.a.m.d.) pentru prelucrarea fișierului:
</p>
<button onclick="myToggle('lab7_ex1_1')">Show / Hide the 1st version of this program</button>
<pre id="lab7_ex1_1" class="stil_codC">
<div w3-include-MyCode="demo/lab6/AsciiStatistics_v1.c">See the code from <a target="_blank" href="demo/lab6/AsciiStatistics_v1.c">here</a>.</div>
</pre>

<p>
<b>2)</b> A doua soluție: <tt class="stil_demo_filename">AsciiStatistics_v2.c</tt> -- este aproape similară cu prima,
dar acum <u>citim în mod eficient de pe disc</u>, i.e. la fiecare apel de sistem <code class="stil_instrC">read()</code> pe care-l facem,
citim câte un bloc de disc, în loc de un singur octet.
<br>
Mai precis, am folosit în program apelul de sistem <code class="stil_instrC">read()</code> cu dimensiunea <tt>BLOCK_SIZE</tt> de 4096,
pentru ca fiecare apel să citească NU un singur octet, ci exact o pagină (sau, puteam alege chiar un multiplu de pagini),
4096 fiind dimensiunea unei pagini, specifică arhitecturii hardware x86/x64.
<br>
<i>Notă</i>: pentru a înțelege aceste aspecte, legate de eficiența execuției apelurilor I/O la nivelul SO-ului,
(re)citiți prezentarea conceptului de <i>file-system cache</i> făcută în topicul ii) din <a href="#sec_1a1">preambulul</a> acestei
pagini de laborator, precum și explicațiile suplimentare date în topicul i) din același preambul.
</p>

<button onclick="myToggle('lab7_ex1_2')">Show / Hide the 2nd version of this program</button>
<pre id="lab7_ex1_2" class="stil_codC">
<div w3-include-MyCode="demo/lab6/AsciiStatistics_v2.c">See the code from <a target="_blank" href="demo/lab6/AsciiStatistics_v2.c">here</a>.</div>
</pre>
</div>
<p class="stil_observatie_level0">
<i>Notă</i>: observați cum am tratat toate cazurile de erori/excepții posibile să apară la execuția programului.
<br>
<i>Recomandare</i>: încercați să adoptați această manieră de lucru în toate programele pe care le veți dezvolta ulterior!
</p>
<br>
</li>



<li><!-- Problema: lab7_ex3.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyFind #1]</span><!-- MyFind&amp;Stat -->
<br>Să se scrie un program C care să parcurgă directorul dat ca argument în linia de comandă, în manieră recursivă (i.e.,
întregul subarbore cu rădăcina în directorul dat), iar pentru toate fișierele (și subdirectoarele) întâlnite prin parcurgere,
să afișeze numele fișierului, tipul lui, dimensiunea, permisiunile în format simbolic și octal, precum și proprietarul și grupul proprietar.
<br>
<small>(Indicație: <span class="stil_hint2">parcurgeți recursiv subarborele cu rădăcina în directorul dat; pentru parcurgerea unui nivel, folosiți șablonul
indicat în lecția practică și, pentru fiecare intrare din director, utilizați apelul de sistem stat() pentru a afla informațiile cerute în enunț.</span>)</small>
</p>

<button onclick="myToggle('lab7_ex3')">Show / Hide a possible solution</button>
<div id="lab7_ex3" class="stil_rezolvare">
Iată o posibilă soluție, completă (i.e., se tratează și toate erorile posibile):
<pre class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyFind-1.c">See the code from <a target="_blank" href="demo/lab6/MyFind-1.c">here</a>.</div>
</pre>
</div>
<p class="stil_observatie_level0">
<i>Notă</i>: observați cum am "factorizat" codul, i.e. am descompus rezolvarea problemei în mai multe funcții, nu am "îngrămădit-o" pe toată doar în funcția main!
<br>
<i>Recomandare</i>: încercați să adoptați această manieră de lucru în toate programele mai complexe pe care le veți dezvolta ulterior!
Este recomandat ca dimensiunea codului sursă al fiecărei funcții să nu depășească un ecran (ori, maxim două ecrane, în cazuri justificate),
pentru o mai bună vizibilitate a codului, ceea ce ajută la așa-numita proprietate de <i>readability of code</i> (pe lângă multe alte tehnici,
precum ar fi: scrierea indentată a codului, alegerea unor nume sugestive ca identificatori pentru variabile/funcții, ș.a.).
</p>
<br>
</li>



<li><!-- Problema: lab7_ex4.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[ArithmeticMean]</span>
<br>Să se scrie un program C care să realizeze prelucrările descrise în continuare.
Într-un fișier text este stocată o secvență de numere întregi.
Să se calculeze media aritmetică pentru fiecare grup de numere cuprinse între două numere cu valoarea zero din fișier.
Să se scrie valorile calculate pe câte o linie distinctă într-un alt fișier text (fișierul rezultat).
Începutul și sfârșitul fișierului cu secvența de numere "joacă rolul" unui număr cu valoarea zero.
Numele fișierelor sursă și destinație se specifică drept argumente la linia de comandă a programului.
</p>

<button onclick="myToggle('lab7_ex4')">Show / Hide a possible solution</button>

<div id="lab7_ex4" class="stil_rezolvare">
<p>
Iată mai jos o posibilă soluție, completă (i.e., se tratează și toate erorile posibile).
<br>Deoarece fișierele sursă și destinație conțin numere în format text și nu în format binar, vom folosi funcțiile de
citire/scriere formatată <code class="stil_instrC">fscanf()</code> și respectiv <code class="stil_instrC">fprintf()</code> din biblioteca stdio.h din C.
</p>
<p>
<i>Observație</i>: am putea folosi direct apelurile de sistem <code class="stil_instrC">read()</code> și respectiv <code class="stil_instrC">write()</code>
în locul funcțiilor din biblioteca stdio.h, dar atunci ar trebui implementate în programul nostru funcționalitățile de conversie
de la reprezentarea numerelor întregi în format text (i.e., ca secvență de cifre zecimale)
la reprezentarea binară a numerelor întregi (i.e., reprezentarea în complement față de 2), precum și conversia inversă.
Cu alte cuvinte, ar trebui implementate funcționalitățile oferite de funcțiile <code class="stil_instrC">atoi()</code>
și respectiv <code class="stil_instrC">itoa()</code>, însă aceasta NU constituie scopul acestui exercițiu!
</p>
<pre class="stil_codC">
<div w3-include-MyCode="demo/lab6/ArithmeticMean.c">See the code from <a target="_blank" href="demo/lab6/ArithmeticMean.c">here</a>.</div>
</pre>
</div>
<br><br>
</li>



<li><!-- Problema: lab7_ex5.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyExpr]</span>
<br>Într-un fișier text sunt scrise linii de text sub forma: două numere întregi urmate de un caracter, ce poate fi '+', '-', '*' sau '/'.
Să se scrie un program C care citește linia a <tt>N</tt>-a din fișier (considerăm liniile fișierului ca fiind numerotate începând de la 1),
efectuează operația dintre cele două numere și apoi scrie într-un alt fișier text o linie de forma: &nbsp; <i>nr1 operator nr2 = rezultat</i> &nbsp;.
Linia cu calculul respectiv se va adăuga la sfârșitul fișierului cu rezultate.
Numărul de ordine <tt>N</tt> al liniei vizate din fișierul sursă, precum și numele fișierului sursă și al celui cu rezultate
se specifică drept argumente în linia de comandă.
</p>

<button onclick="myToggle('lab7_ex5')">Show / Hide a possible solution</button>

<div id="lab7_ex5" class="stil_rezolvare">
<p>
Iată mai jos o posibilă soluție, completă (i.e. se tratează și toate erorile posibile).
<br>Deoarece fișierele sursă și destinație conțin numere în format text și nu în format binar, vom folosi funcțiile de
citire/scriere formatată <code class="stil_instrC">fscanf()</code> și respectiv <code class="stil_instrC">fprintf()</code> din biblioteca stdio.h din C.
</p>
<p>
<i>Observație</i>: am putea folosi direct apelurile de sistem <code class="stil_instrC">read()</code> și respectiv <code class="stil_instrC">write()</code>
în locul funcțiilor din biblioteca stdio.h, dar atunci ar trebui implementate în programul nostru funcționalitățile de conversie
de la reprezentarea numerelor întregi în format text (i.e., ca secvență de cifre zecimale)
la reprezentarea binară a numerelor întregi (i.e., reprezentarea în complement față de 2), precum și conversia inversă.
Cu alte cuvinte, ar trebui implementate funcționalitățile oferite de funcțiile <code class="stil_instrC">atoi()</code>
și respectiv <code class="stil_instrC">itoa()</code>, însă aceasta NU constituie scopul acestui exercițiu!
</p>
<pre class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyExpr.c">See the code from <a target="_blank" href="demo/lab6/MyExpr.c">here</a>.</div>
</pre>
</div>
<br><br>
</li>



<li><!-- Problema: lab7_ex-new -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Filter programs] (e.g., dos2unix &amp; unix2dos)</span>
<br>Un program de tip <b>filtru</b> este un program care copie conținutul unui fișier de intrare într-un fisier de ieșire,
aplicând în timpul copierii o anumită transformare asupra conținutului copiat.
<br>Exemplu: comenzile <code class="stil_cmdBash">dos2unix</code> și <code class="stil_cmdBash">unix2dos</code>.
<br>
<i>Explicație</i>: fișierele cu text obișnuit folosesc caracterul newline (reprezentat prin '\n' în limbajul C), ca și separator de linie.
Numai că reprezentarea caracterului newline este dependentă de platformă, i.e. de SO-ul pe care ați creat acel fișier,
cu ajutorul unui program de tipul editor de text obișnuit pentru acea platformă!
<br>
Comanda <code class="stil_cmdBash">dos2unix</code> filtrează fișierul de intrare, aplicându-i translatarea reprezentării caracterului newline
folosită de SO-urile DOS și Windows, la reprezentarea caracterului newline folosită de Linux și celelalte SO-uri din familia UNIX.
Iar comanda <code class="stil_cmdBash">unix2dos</code> realizează filtrarea în sens invers.
<br>
<br>
<i>Cerință</i>: să se scrie un program C care primește de la linia de comandă numele a două fișiere și care
va copia conținutul fișierului de intrare în cel de ieșire,
transformând conținutul copiat conform conversiei realizate de comanda <code>dos2unix</code>.
Similar, să se scrie un program C care simulează comanda <code>unix2dos</code>.
</p>

<button onclick="myToggle('lab7_filters')">Show / Hide the solutions</button>
<div id="lab7_filters" class="stil_rezolvare">
<p>
<b>1)</b> Primul program, <a href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/dos2unix.c">dos2unix.c</a>,
implementează conversia realizată de comanda <code class="stil_cmdBash">dos2unix</code>.
</p>
<button onclick="myToggle('lab7_filters_d2u')">Show / Hide the 1st program</button>
<pre id="lab7_filters_d2u" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/dos2unix.c">See the code from <a target="_blank"
href="../../lectures/Linux/demo/files/dos2unix.c">here</a>.</div>
</pre>

<p>
<b>2)</b> Al doilea program, <a href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/demo/files/unix2dos.c">unix2dos.c</a>,
implementează conversia realizată de comanda <code class="stil_cmdBash">unix2dos</code>.
</p>
<button onclick="myToggle('lab7_filters_u2d')">Show / Hide the 2nd program</button>
<pre id="lab7_filters_u2d" class="stil_codC">
<div w3-include-MyCode="../../lectures/Linux/demo/files/unix2dos.c">See the code from <a target="_blank"
href="../../lectures/Linux/demo/files/unix2dos.c">here</a>.</div>
</pre>
</div>

<div class="stil_observatie_level0">
<b>Topici avansate</b> (<i>pentru studenții mai buni, pasionați de tehnologie, ce doresc să afle informații și despre alte subiecte suplimentare, în plus față de setul minimal de cunoștințe predat în cadrul disciplinei SO</i>) :
<br>
Iată o explicație detaliată despre reprezentările diferite ale caracterului newline pe platforme diferite
și impactul acestor reprezentări asupra "portabilității" fișierelor text obișnuite:
<button onclick="myToggle('lab6_filters_details')">Show / Hide the full details</button>
<div id="lab6_filters_details" class="stil_hidden-text_level1">
<p>
Mai precis, reprezentarea caracterului newline folosită de Linux și celelalte SO-uri din familia UNIX
constă în stocarea în fișier a caracterului LF (i.e., caracterul cu codul ASCII 10), ca delimitator între liniile de text.
În schimb, sistemele de operare DOS și Windows folosesc ca și reprezentare a caracterului newline,
o secvență de două caractere, și anume: caracterul CR (i.e., caracterul cu codul ASCII 13), urmat de caracterul LF (i.e., caracterul cu codul ASCII 10).
Iar vechile versiuni de Mac OS (cele dinainte de Mac OS X) foloseau ca și reprezentare a caracterului newline, doar  caracterul CR (i.e., caracterul cu codul ASCII 13).
O dată cu trecerea la versiunile de Mac OS X, care este un SO diferit de vechiul Mac OS, fiind bazat pe UNIX, în prezent Mac OS X folosește caracterului LF (i.e.,
caracterul cu codul ASCII 10), ca delimitator între liniile de text, la fel ca și în UNIX.
Pentru mai multe detalii, puteți consulta informațiile de <a href="https://en.wikipedia.org/wiki/Newline">aici</a>, precum și pagina
de documentație: <code class="stil_cmdBash">man dos2unix</code>.
</p>

<p>
Impactul acestei diferențe de reprezentare asupra "portabilității" fișierelor text obișnuite între platforme diferite:
<ul>
<li>i) dacă deschidem un fișier text, creat anterior sub Linux, în Windows cu editorul clasic Notepad, vom vedea tot textul din fișier pe o singură linie,
eventual "wrapped" pe ecran, în funcție de setarea curentă "Word Wrap: yes or no" pe care o aveți în Notepad.
<br><i>Notă</i>: mai sunt și alte editoare în Windows care se comportă precum Notepad-ul.
Iar altele, cum ar fi Notepad++, se comportă în mod "inteligent", în sensul că efectuează singure conversia necesară atunci când "interpretează" conținutul
fișierului pentru a-l afișa pe ecran.
<br><i>Remarcă</i>:
abia în 2020, după foarte mulți ani, versiunea de Notepad livrată începând cu versiunea 2004 de Windows 10 a căpătat în sfârșit
capabilitatea de "comportament inteligent la detecția newline-urilor", în sensul celor spuse în nota anterioară.
</li>
<li>ii) dacă deschidem un fișier text, creat anterior sub Windows, în Linux cu editorul mcedit, vom vedea la finalul fiecărei linii de text
secvența "^M" pe un background de culoare neagră, secvență prin care mcedit reprezintă pe ecran caracterul CR, ceea ce poate fi deranjant.
<br><i>Notă</i>: mai sunt și alte editoare în Linux care se comportă precum mcedit-ul.
Iar altele  se comportă în mod "inteligent", în sensul că efectuează singure conversia necesară atunci când "interpretează" conținutul fișierului
pentru a-l afișa pe ecran.
</li>
</ul>
<br>
<i>Observație</i>:
cele spuse mai sus sunt valabile dacă ați transferat fișierul respectiv între cele două platforme fără să-i aplicați, în mod voluntar sau nu,
o conversie între cele două reprezentări diferite în timpul "transferului".
Spre exemplu, dacă din Linux copiați fișierul dorit între o partiție de Linux și una folosită de Windows, cu file-managerul din distribuția dvs.
de Linux, atunci copia va fi identică cu originalul, i.e. fără să se facă nicio conversie în timpul "transferului".
<br>În schimb, dacă copiați fișierul respectiv între calculatorul local și un server, folosind comenzi de genul ftp, scp, sftp, etc.,
sau aplicații cu interfață grafică de genul WinSCP,
atunci trebuie să fiți atenți la faptul că aceste comenzi și aplicații au, de regulă, o setare cu trei valori posibile:
i) transferă orice fișier fără nicio conversie (modalitate de copiere numită și "transfer binar");
ii) transferă orice fișier aplicându-i conversia necesară între cele două reprezentări diferite, în funcție de SO-ul de pe
calculatorul local și cel de pe server (modalitate de copiere numită și "transfer text");
iii) transferă fișierele aplicându-le modul de "transfer binar" sau cel de "transfer text", pe baza extensiei din numele lor (e.g.,
pentru un fișier cu numele nume.txt sau sau pagina.html se va aplica automat modul de transfer text).
De asemenea, au și o valoare implicită, una dintre aceste 3 valori, pentru setarea respectivă.
<br>
<br>
Ceva similar celor descrise în observația de mai sus, se poate întâmpla și când transferați un text, cu <i>copy-paste</i>, dintr-o fereastră
din Windows într-un editor din Linux, cum ar fi mcedit-ul, atunci când lucrați cu Linux-ul instalat într-o mașină virtuală sub Windows.
</p>
</div>
</div>
<br>
</li>


<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b3">c) <span class="stil_ex_rezolvate">Exemple de programe C ce implementează comenzi uzuale din Unix/Linux</span> :</p>


<li><!-- Problema: lab7_ex6.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyWc]</span>
<br>Să se scrie un program C care să implementeze comanda <code class="stil_cmdBash">wc</code>, inclusiv cu opțiunile sale
<tt class="stil_cmdBash">-c</tt>, <tt class="stil_cmdBash">-w</tt>, <tt class="stil_cmdBash">-l</tt> și <tt class="stil_cmdBash">-L</tt>.
<br>
<small>(Atenție: <span class="stil_hint2">se cere să se scrie cod C care realizează aceeași funcționalitate ca și comanda wc,
deci nu în sensul ca să apelați direct comanda wc dintr-un program C folosind funcțiile system() sau exec().</span>)</small>
<br>
<br>
<i>Cerință</i> (valabilă și pentru exercițiul de mai jos, precum și pentru toate celelalte exerciții, asemănătoare cu acest exercițiu,
din pagina cu exerciții de laborator propuse spre rezolvare, disponibilă <a target="_blank" href="../../labs/C/lab6.html">aici</a>):
implementarea comenzii <i>cmd</i>, inclusiv a unei opțiuni <i>-o</i>, presupune următoarele lucruri:
<br>-- implementarea comportamentului implicit al comenzii respective: &nbsp;
	<i>cmd nume_fisier</i>
<br>-- în plus, și implementarea comportamentului modificat pe baza opțiunii precizate în enunț: &nbsp;
	<i>cmd -o nume_fisier</i>
</p>

<button onclick="myToggle('lab7_ex6')">Show / Hide the solutions</button>
<div id="lab7_ex6" class="stil_rezolvare">
<p>
<b><i>Ideea de rezolvare</i>:</b> se parcurge/citește fișierul octet cu octet.
Pentru statisticile asociate opțiunilor <tt class="stil_cmdBash">-c</tt> și <tt class="stil_cmdBash">-l</tt>, este suficient să "observ" doar
caracterul curent citit, i.e. dacă octetul citit este '\n', atunci incrementez numărul de linii.
Totodată, indiferent de ce valoare are octetul citit, incrementez numărul de caractere și, de asemenea,
pentru opțiunea <tt class="stil_cmdBash">-L</tt> mai trebuie să fac următoarele operații: incrementez lungimea liniei curente și,
doar dacă octetul citit este '\n', atunci actualizez maximul și apoi resetez lungimea liniei curente.
<br>În schimb, pentru statistica asociată opțiunii <tt class="stil_cmdBash">-w</tt>, nu mai este suficient să "observ" doar caracterul curent citit,
ci trebuie să "observ" și istoricul, i.e. aici e suficient să "observ" doar octetul precedent.
Practic, detecția unui cuvânt se poate face folosind <b>automatul determinist finit</b> descris în următoarea diagramă:
<br>
<!--div align="center"><img src="xerox_files/Lab7_ex1a__IMG_20190502_183703_cr.jpg" width="50%"></div-->
<div style="width: 50%; margin: auto;" class="stil_image_frame"><img width="95%" src="xerox_files/Lab6_MyWc__IMG_20190502_183703_cr.jpg" align="middle"></div>
<br>
<i>Observație</i>: despre teoria automatelor deterministe finite și aplicațiile lor în analiza lexicală (i.e., parsarea) unui program scris
într-un limbaj de programare, veți învăța în anul 2 la disciplina LFAC = Limbaje formale, automate și compilatoare.
</p>

<p>
<b>1)</b> Prima soluție: <tt class="stil_demo_filename">MyWc_v1.c</tt> -- iată mai jos o primă variantă de rezolvare,
ce este incompletă și neoptimizată!
<br>Este incompletă, deoarece nu s-a implementat și tratarea opțiunii <tt class="stil_cmdBash">-L</tt>.
<br>Este neoptimizată, în sensul că cele 3 numere/statistici se calculează întotdeauna, dar se afișează dintre ele
numai acelea pentru care sunt prezente opțiunile corespunzătoare.
</p>
<button onclick="myToggle('lab7_ex6_1')">Show / Hide the 1st version of this program</button>
<pre id="lab7_ex6_1" class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyWc_v1.c">See the code from <a target="_blank" href="demo/lab6/MyWc_v1.c">here</a>.</div>
</pre>

<p>
<b>2)</b> A doua soluție: <tt class="stil_demo_filename">MyWc_v2.c</tt> -- iată mai jos o variantă de rezolvare,
ce este completă și optimizată!
<br>Este completă, deoarece s-a implementat inclusiv tratarea opțiunii <tt class="stil_cmdBash">-L</tt>,
pe lângă celelalte trei implementate deja în prima variantă.
<br>Este optimizată, în sensul că cele 4 numere/statistici nu se mai calculează întotdeauna, ci se calculează și se afișează dintre ele
numai acelea pentru care sunt prezente opțiunile corespunzătoare.
</p>
<button onclick="myToggle('lab7_ex6_2')">Show / Hide the 2nd version of this program</button>
<pre id="lab7_ex6_2" class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyWc_v2.c">See the code from <a target="_blank" href="demo/lab6/MyWc_v2.c">here</a>.</div>
</pre>

<p>
<b><i>Notă</i>:</b> observați că ambele variante de programe, date mai sus, folosesc funcțiile din biblioteca standard I/O din C,
pentru a prelucra conținutul fișierului de intrare.
Evident, în locul funcțiilor din biblioteca standard I/O din C, ambele variante ar putea fi rescrise echivalent astfel încât să folosească
apelurile de sistem specifice din API-ul POSIX, pentru a prelucra conținutul fișierului de intrare.
<br><br>
<font color="red">// TODO:</font> vă las ca exercițiu sarcina acestei rescrieri!
</p>
</div>
<br><br>
</li>


<li><!-- Problema: lab7_ex7.c -------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyCp]</span>
<br>Să se scrie un program C care să implementeze comanda <code class="stil_cmdBash">cp</code>, inclusiv cu opțiunile sale
<tt class="stil_cmdBash">-i</tt> și <tt class="stil_cmdBash">-u</tt>.
<br>
<small>(Atenție: <span class="stil_hint2">se cere să se scrie cod C care realizează aceeași funcționalitate ca și comanda cp,
deci nu în sensul ca să apelați direct comanda cp dintr-un program C folosind funcțiile system() sau exec().
SIMILAR și pentru toate celelalte exerciții, asemănătoare cu acest exercițiu,
din pagina cu exerciții de laborator propuse spre rezolvare, disponibilă <a target="_blank" href="../../labs/C/lab6.html">aici</a> !</span>)</small>
</p>

<button onclick="myToggle('lab7_ex7')">Show / Hide the solutions</button>

<div id="lab7_ex7" class="stil_rezolvare">
<p>
<b><i>Ideea de rezolvare</i>:</b> se parsează argumentele din linia de comandă, pentru a obține numele fișierului sursă și al celui destinație,
precum și pentru a vedea dacă s-au specificat opțiunile <tt class="stil_cmdBash">-u</tt> sau/și <tt class="stil_cmdBash">-i</tt>.
Apoi se adaptează comportamentul la copiere conform celor două opțiuni, în caz că sunt prezente (fie ambele, fie doar vreuna dintre ele):
opțiunea <tt class="stil_cmdBash">-u</tt> înseamnă <i>update</i>, adică în cazul în care fișierul destinație deja există, atunci se face copiere
prin suprascriere NUMAI dacă atributul "timpul ultimei modificări" al fișierului sursă este mai recent decât cel al fișierului destinație.
Opțiunea <tt class="stil_cmdBash">-i</tt> înseamnă <i>interactive</i>, adică în cazul în care fișierul destinație deja există, atunci se va
întreba utilizatorul dacă dorește suprascrierea.
Iar în cazul când ambele opțiuni sunt prezente, opțiunea <tt class="stil_cmdBash">-u</tt> este mai prioritară decât
opțiunea <tt class="stil_cmdBash">-i</tt>.
</p>

<p>
<b>1)</b> Prima soluție: <tt class="stil_demo_filename">MyCp_POSIX.c</tt> -- iată mai jos o primă variantă de rezolvare,
și observați că este completă (i.e. se tratează și toate erorile posibile).
Ea folosește apeluri de sistem specifice platformei Linux/UNIX (i.e., API-ul POSIX).
</p>
<button onclick="myToggle('lab7_ex7_1')">Show / Hide the 1st version of this program</button>
<pre id="lab7_ex7_1" class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyCp_POSIX.c">See the code from <a target="_blank" href="demo/lab6/MyCp_POSIX.c">here</a>.</div>
</pre>

<p>
<i>Observație</i>: citirile / scrierile de pe/pe disc la nivel fizic (hardware) se efectuează prin transferuri de unități exprimate în blocuri fizice de disc
(aka sectoare), nu în octeți individuali.
Mai mult, pentru eficiența operațiilor I/O cu discul la nivel software (i.e., pentru a obține un spor și mai mare de performanță),
apelurile de citire / scriere trebuie să transfere informație la nivel de pagină.
Pentru a înțelege aceste aspecte, legate de modul de execuție a apelurilor I/O la nivelul SO-ului,
(re)citiți prezentarea conceptului de <i>file-system cache</i> făcută în topicul ii) din <a href="#sec_1a1">preambulul</a> acestei pagini de laborator,
precum și explicațiile suplimentare date în topicul i) din același preambul.
<br>
Din acest motiv, am folosit în program apelurile de sistem <code class="stil_instrC">read()</code> și respectiv <code class="stil_instrC">write()</code>
cu dimensiunea <tt>BLOCK_SIZE</tt> de 4096,
pentru ca fiecare apel să citească/scrie NU un singur octet, ci exact o pagină (sau, puteam alege chiar un multiplu de pagini),
4096 fiind dimensiunea unei pagini, specifică arhitecturii hardware x86/x64.
</p>


<p>
<b>2)</b> A doua soluție: <tt class="stil_demo_filename">MyCp_stdio.c</tt> -- iată mai jos o altă variantă de rezolvare,
și observați că este completă (i.e. se tratează și toate erorile posibile).
Am obținut-o din prima soluție de mai sus, rescriind DOAR funcția <code class="stil_instrC">copie_simpla()</code>,
ce realizează copierea efectivă, astfel încât să folosească funcțiile din biblioteca standard I/O din C,
în locul apelurilor de sistem specifice platformei Linux/UNIX (i.e., API-ul POSIX).
</p>
<button onclick="myToggle('lab7_ex7_2')">Show / Hide the 2nd version of this program</button>
<pre id="lab7_ex7_2" class="stil_codC">
<div w3-include-MyCode="demo/lab6/MyCp_stdio.c">See the code from <a target="_blank" href="demo/lab6/MyCp_stdio.c">here</a>.</div>
</pre>

<p>
<i>Observație</i>: după cum spuneam în alte ocazii, pentru eficiența operațiilor I/O cu discul,
citirea fizică de pe disc trebuie să se facă la nivel de bloc de disc, nu la nivel de octeți individuali.
Totuși, după cum puteți observa, în această a doua soluție am rescris funcția <code class="stil_instrC">copie_simpla()</code> folosind apeluri de
citire/scriere a câte unui singur octet, fără a pierde eficiența operațiilor I/O cu discul. Cum se explică acest lucru?
<i>Răspuns</i>: acest lucru se explică prin faptul că funcțiile din biblioteca standard I/O din C lucrează <i>buffer</i>izat,
mai precis sunt două nivele de <i>cache</i> până la disc: cel gestionat de biblioteca stdio, per proces,
și cel gestionat de SO, per sistem.
(<i>Notă</i>: pentru a înțelege aceste aspecte, legate de eficiența execuției apelurilor I/O din biblioteca stdio,
(re)citiți prezentarea conceptului de <i>cache</i>uri gestionate de biblioteca stdio făcută în topicul iii) din
<a href="#sec_1a1">preambulul</a> acestei pagini de laborator, precum și explicațiile suplimentare date în topicurile i) și ii) din același preambul.)
</p>

<p>
<i>Notă</i>: totuși, mai putem obține un mic spor de performanță,
prin minimizarea numărului de apeluri ale funcțiilor de bibliotecă făcute pentru a citi sau scrie o pagină,
adică prin înlocuirea apelurilor de citire/scriere a câte unui singur octet,
cu apeluri de citire/scriere a câte unei pagini întregi, i.e. câte 4096 octeți per apel.
Cu alte cuvinte, un singur apel <code class="stil_instrC">fread/fwrite(&page, 1, 4096, fd);</code> este mai eficient, ca timp de execuție,
decât bucla echivalentă:
<code class="stil_instrC">for(int offset = 0; offset &lt; 4096; offset++) fscanf/fprintf(fd,"%c",&page+offset);</code> &nbsp;.
Iar pentru acest tip de optimizare este <u>direct responsabil</u> programatorul care scrie o aplicație,
biblioteca stdio nu poate "interveni" pentru a "rescrie" programul executabil în sensul realizării unei astfel de optimizări.
</p>

<p>
<i>Remarcă</i>: cealaltă funcție din primul program ce folosește API-ul POSIX,
i.e. funcția <code class="stil_instrC">copie_opts_i_u()</code>,
este mai dificil să fie rescrisă să folosească funcțiile din biblioteca standard I/O din C,
în locul apelurilor de sistem specifice API-ului POSIX.
Cele două apeluri <code class="stil_instrC">access()</code> din această funcție ar putea fi "simulate" cu apeluri adecvate
<code class="stil_instrC">fopen()</code> și testarea succesului/eșecului la deschidere.
În schimb, apelurile <code class="stil_instrC">stat()</code> necesare pentru a afla atributele "timpul ultimei modificări" ale
celor două fișiere nu prea avem cum să le "simulăm" cu apeluri de funcții din biblioteca standard I/O din C.
</p>
</div>

<p class="stil_observatie_level0">
<i style="color:red;">Observație importantă</i>: precum ați putut observa din cele două exemple rezolvate de mai sus,
și mai ales din primul dintre ele, partea de cod care parsează opțiunile din linia de comandă și le clasifică pentru a apela
diverse procesări pe baza lor, poate fi destul de complexă și, prin urmare, supusă posibilității de a face ușor greșeli de programare, mai ales atunci când numărul de opțiuni posibile este suficient de mare.
În plus, unele opțiuni ar putea avea și valori asociate (nu a fost cazul în cele două exemple rezolvate de mai sus),
ceea ce conduce la o complexitate și mai mare a codului de parsare a acestora.
<br>
Din acest motiv, această funcționalitate (i.e., "parsarea opțiunilor din linia de comandă") a fost deja implementată în
biblioteca standard de C, prin intermediul funcției
<a target="_blank" href="https://www.man7.org/linux/man-pages/man3/getopt.3.html">getopt()</a>,
ce poate fi folosită de programatorii de aplicații pentru a obține funcționalitatea respectivă în programele lor.
<br><br>
<i>TODO</i>:
vă las ca exercițiu să faceți dvs. modificările necesare în cele două exemple rezolvate de mai sus, prin care să implementați
ideea de apelare a funcției <code class="stil_instrC">getopt()</code> pentru parsarea opțiunilor specificate în enunțurile
respective.
</p>
<!--br><br-->
</li>

</ol>



<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<hr style="border-top:3px solid darkblue;">
<script src="../js/script_toggle.js"></script>
<script>includeMyCode();</script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</body>
</html>
