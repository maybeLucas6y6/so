<!DocType html>
<html lang="ro">
<head>
  <title>Disciplina SO - Laborator #4 (suport online)</title>
  <link rel="stylesheet" type="text/css" href="../my_styles.css" />
    <meta name="description" content="Sisteme de operare - curs și laborator - suport electronic">
    <meta name="keywords"    content="Operating Systems, Sisteme de operare, Unix, Linux, FII Iași, infoiasi, Cristian Vidrașcu">
    <meta name="author"      content="Cristian Vidrașcu">
    <meta charset="utf-8"><!-- pentru diacritice -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<script src="../js/script_include.js"></script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<h2><font color="blue">Laborator #4 :</font> suport online &nbsp; ( Îndrumar de laborator )</h2>

<b>Sumar:</b>
<h3>I) <a href="#sec_1" class="button_href">Lucrul la linia de comandă în Linux, cu fișiere de comenzi (partea întâia)</a></h3>
<h4>I.1) Recap: <a href="#sec_1a" class="button_href">Reamintirea unor cunoștințe dobândite în lecția practică despre interpretoare de comenzi, partea a II-a</a></h4>
<h4>I.2) Exemplificări: <a href="#sec_1b" class="button_href">Exemple de utilizare a unor fișiere de comenzi (exerciții rezolvate)</a></h4>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; a) <a href="#sec_1b1" class="button_href">Primele exemple de <i>script</i>-uri</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; b) <a href="#sec_1b2" class="button_href">Exemple de <i>script</i>-uri ce efectuează diverse calcule matematice iterative</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; c) <a href="#sec_1b3" class="button_href">Exemple de <i>script</i>-uri ce efectuează diverse calcule matematice recursive</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; d) <a href="#sec_1b4" class="button_href">Exemple de <i>script</i>-uri <b>cooperante</b>, ce efectuează diverse calcule matematice</a></h5>
<h4>I.3) Exemplificări: <a href="#sec_1c" class="button_href">Corectarea unor greșeli ``strecurate'' într-un script dat</a></h4>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:5px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1">I) <span class="stil_sumar">Lucrul la linia de comandă în Linux, cu fișiere de comenzi (partea întâia)</span> :</p>

<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a">I.1) <span class="stil_recap">Reamintirea unor cunoștințe dobândite în lecția practică despre interpretoare de comenzi, partea a II-a</span> :</p>

<b>Informații despre limbajul de <i>scripting</i> bash pentru automatizarea lucrului la linia de comandă în Linux:</b>
<button onclick="myToggle('lab4_recap')">Hide / Show the presentation</button>
<div id="lab4_recap" style="display:block;" class="stil_prezentare">
<p>
(Re)citiți prezentarea cu lecția practică despre interpretoare de comenzi în Linux - partea a II-a, disponibilă
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/P4_shell2_web-ro.pdf">aici</a>.
</p>
<p>
<font color="red">Recomandare:</font>
<button onclick="myToggle('lab4_recap_bib')">Show / Hide the recommendation</button>
<div id="lab4_recap_bib" class="stil_bibliografie_suplimentara">
Nu vă rezumați doar la consultarea prezentării PPT indicate  mai sus;
citiți și subcapitolul corespunzător din cartea recomandată pentru componenta practică:
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/shellprg.pdf">Cap. 2, §2.4</a>.
<!--
<br><br>
<i>Notă</i>: o versiune mai veche a acestui material, în format HTML, este disponibilă spre consultare
<a target="_blank" href="http://students.info.uaic.ro/~so/labs/shellprg.htm">aici</a>.
-->
</div>
</p>
</div>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:3px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b">I.2) <span class="stil_ex_rezolvate">Exemple de utilizare a unor fișiere de comenzi (exerciții rezolvate)</span> :</p>

<ol>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b1">a) <span class="stil_ex_rezolvate">Primele exemple de <i>script</i>-uri</span> :</p>


<li><!-- Problema: exemplul-1.sh ----------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[FirstScript]</span>
<br>
Să se scrie un script care să listeze toți parametrii din linia de apel sub forma:
<tt style="color:blue;">param_i = <i>valoarea parametrului al i-lea</i></tt> ,
cu i luând valori de la 1 la numărul total de parametri.
</p>

<button onclick="myToggle('lab4_exemplul1')">Show / Hide the solutions</button>
<div id="lab4_exemplul1" class="stil_rezolvare">
Ideea de rezolvare este să parcurgem lista de parametri cu care este apelat scriptul nostru și să-i afișăm în formatul cerut.
<p>
Parcurgerea o putem face în mai multe moduri, și anume:
</p>

<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">FirstScript_v1.sh</tt> -- 
folosim o structură repetitivă <code class="stil_cmdBash">for</code> pentru a parcurge lista de parametri,
ce este stocată în variabila dinamică <tt class="stil_cmdBash">$@</tt> :
</p>
<button onclick="myToggle('lab4_exemplul1_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_exemplul1_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v1.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v1.sh">here</a>.</div>
</pre>

<br>
<div class="stil_QandA"><i>Întrebare</i>: cum lansăm în execuție un script? 
<i>Răspuns</i>: o putem face prin oricare dintre cele 3 forme de execuție în <i>foreground</i>, respectiv
cele 3 forme de execuție în <i>background</i>, prezentate în lecția practică din această săptămână.
</div>

<p>
Pentru exemplificare, iată cum executăm scriptul acesta prin prima formă de execuție a unei comenzi în <i>foreground</i>:
<br>
<button onclick="myToggle('lab4_exemplul1_1_1')">Show / Hide the 1st form of running this script in foreground</button>
<div id="lab4_exemplul1_1_1" class="stil_hidden-text_level1">
Introducem la prompter următoarea comandă, presupunând că directorul curent de lucru este chiar directorul ce conține scriptul respectiv:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> FirstScript_v1.sh a b c</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
FirstScript_v1.sh: command not found
</pre>
<b>Motivul acestui mesaj de eroare</b>:
pentru fișierele specificate doar prin numele lor simplu, fără nicio cale (absolută sau relativă) ca prefix,
interpretorul <tt>bash</tt> NU va căuta fișierul în directorul curent de lucru, precum se întâmplă în Windows,
ci trece direct la căutarea lui în directoarele din lista definită prin variabila de mediu PATH.
<br>
Soluționarea acestei erori este foarte simplă:
<br>
1) soluția permanentă: se adaugă directorul curent de lucru, identificat prin numele <tt class="stil_cmdBash">.</tt> , la variabila
de mediu PATH (în fișierele de inițializare pentru <tt>bash</tt>);
<br>sau 2) soluția temporară:
se specifică numele fișierului prin cale absolută, sau prin cale relativă la directorul curent de lucru, atunci când îl lansăm în
execuție; presupunând că directorul curent de lucru este chiar directorul ce conține scriptul respectiv, vom proceda astfel:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./FirstScript_v1.sh a b c</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
bash: ./FirstScript_v1.sh: Permission denied
</pre>
<b>Motivul acestui mesaj de eroare</b>:
pentru prima formă de execuție a unei comenzi (în <i>foreground</i>), fișierul respectiv trebuie să aibă permisiune de execuție
pentru utilizatorul curent.
Iar editorul în care ați scris scriptul de mai sus este un editor obișnuit pentru plain-text, ca atare implicit creează fișierul cu
permisiuni de citire și scriere, dar nu și de execuție, pentru proprietarul său.
<br>
Soluționarea acestei erori este foarte simplă:
se adaugă fișierului permisiunea de execuție pentru proprietar, de exemplu prin comanda următoare:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> chmod u+x FirstScript_v1.sh</code>
<br>
(<i>Atenție</i>: este suficient să faceți această operație o singură dată, NU este necesar să o faceți după fiecare modificare a conținutului fișierului!)
<br>
Iar acum putem repeta comanda de execuție a scriptului prin prima formă de execuție în <i>foreground</i> și de data aceasta
nu ne va mai da erori:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./FirstScript_v1.sh a bb ccc</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestui script:
<pre class="stil_output">
param_1 = a
param_2 = bb
param_3 = ccc
</pre>
</div>
</p>

<p>
Pentru exemplificare, iată cum executăm scriptul acesta prin a doua formă de execuție a unei comenzi în <i>foreground</i>:
<br>
<button onclick="myToggle('lab4_exemplul1_1_2')">Show / Hide the 2nd form of running this script in foreground</button>
<div id="lab4_exemplul1_1_2" class="stil_hidden-text_level1">
Introducem la prompter următoarea comandă, presupunând că directorul curent de lucru este chiar directorul ce conține scriptul respectiv:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> /bin/bash FirstScript_v1.sh a b c d</code>
<br>
sau, echivalent, putem apela shell-ul dorit doar prin numele său individual, fără calea completă, astfel:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> bash FirstScript_v1.sh a b c d</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
param_1 = a
param_2 = b
param_3 = c
param_4 = d
</pre>
<i>Notă</i>: pentru forma aceasta, nu este necesar ca scriptul să aibă setată permisiunea de execuție pentru proprietar și,
de asemenea, putem să specificăm scriptul doar prin numele lui simplu, fără nicio cale (absolută sau relativă) ca prefix,
atunci când directorul curent de lucru este chiar directorul ce conține scriptul respectiv.
<br>
<br>
Iată și un exemplu de apelare a scriptului folosind un alt interpretor de comenzi:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> /bin/dash FirstScript_v1.sh a b c d</code>
<br>
sau, echivalent, putem apela shell-ul dorit doar prin numele său individual, fără calea completă, astfel:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> dash FirstScript_v1.sh a b c d</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
FirstScript_v1.sh: 7: let: not found
param_0 = a
FirstScript_v1.sh: 7: let: not found
param_0 = b
FirstScript_v1.sh: 7: let: not found
param_0 = c
FirstScript_v1.sh: 7: let: not found
param_0 = d
</pre>
<i>Explicație</i>: precum vă spuneam și în suportul de laborator precedent,
<tt>/bin/dash</tt> este interpretorul <i>Debian Almquist Shell</i>, o implementare POSIX-conformantă a vechiului
interpretor <i>Bourne Shell</i>, <tt>/bin/sh</tt>, din variantele vechi de UNIX.
Iar <tt>/bin/bash</tt> este interpretorul <i>Bourne Again Shell</i> dezvoltat de proiectul GNU, fiind inspirat atât din <i>Bourne Shell</i>, cât și din alte două shelluri, <i>C Shell</i> și <i>Korn Shell</i>.
<br>
Ca urmare, din punct de vedere al funcționalităților oferite, shellul <tt>/bin/dash</tt> este o versiune foarte simplificată
a shellului <tt>/bin/bash</tt> (pentru mai multe detalii, citiți <a target="_blank" href="https://www.cyberciti.biz/faq/debian-ubuntu-linux-binbash-vs-bindash-vs-binshshell/">aici</a>).
<br>
Astfel, studiind documentația interpretorului <tt>/bin/dash</tt>, disponibilă <a target="_blank" href="https://man7.org/linux/man-pages/man1/dash.1.html">aici</a>, putem constata faptul că acest shell nu posedă comanda internă let,
ceea ce explică mesajele de eroare pe care le vedeți în outputul de mai sus,
precum și faptul că variabila i nu este incrementată la fiecare iterație a buclei for.
</div>
</p>

<p>
Pentru exemplificare, iată cum executăm scriptul acesta prin a treia formă de execuție a unei comenzi în <i>foreground</i>:
<br>
<button onclick="myToggle('lab4_exemplul1_1_3')">Show / Hide the 3rd form of running this script in foreground</button>
<div id="lab4_exemplul1_1_3" class="stil_hidden-text_level1">
Introducem la prompter următoarea comandă, presupunând că directorul curent de lucru este chiar directorul ce conține scriptul respectiv:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> source FirstScript_v1.sh x yy zzz</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
param_1 = x
param_2 = yy
param_3 = zzz
</pre>
<i>Notă</i>: și pentru forma aceasta, nu este necesar ca scriptul să aibă setată permisiunea de execuție pentru proprietar și,
de asemenea, putem să specificăm scriptul doar prin numele lui simplu, fără nicio cale (absolută sau relativă) ca prefix,
atunci când directorul curent de lucru este chiar directorul ce conține scriptul respectiv.
</div>
</p>

<p>
Rețineți formele de lansare în execuție a unui script demonstrate în rândurile de mai sus, căci nu le voi mai repeta și
pentru toate exemplele de scripturi ilustrate în cele ce urmează.
Procedați asemănător ca mai sus pentru a testa (executa) toate exemplele de scripturi ilustrate în cele ce urmează.
</p>

<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">FirstScript_v2.sh</tt> -- este o variație minoră a primei soluții, și anume
folosim cealaltă variabilă dinamică <tt class="stil_cmdBash">$*</tt> și, în plus, operația de incrementare este scrisă altfel :
</p>
<button onclick="myToggle('lab4_exemplul1_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_exemplul1_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v2.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v2.sh">here</a>.</div>
</pre>
</p>


<p>
<b>iii)</b> A treia soluție: <tt class="stil_demo_filename">FirstScript_v3.sh</tt> -- 
folosim o idee diferită: comanda internă <code class="stil_cmdBash">shift</code>,
care deplasează spre stânga cu o poziție toți parametrii poziționali <tt class="stil_cmdBash">$1 $2 ... $9 ${10} ${11} ... </tt> ,
și actualizează în mod corespunzător și variabilele <tt class="stil_cmdBash">$#</tt>, <tt class="stil_cmdBash">$@</tt> și <tt class="stil_cmdBash">$*</tt> .
<br>Practic, la fiecare iterație facem câte o <i>shift</i>-are și afișăm parametrul curent <tt class="stil_cmdBash">$1</tt>,
care va fi pe rând parametrul 1, apoi al 2-lea, apoi al 3-lea, ș.a.m.d. din linia de apel inițială.
<br>În plus, vom folosi o structură repetitivă <code class="stil_cmdBash">while</code> în loc de <code class="stil_cmdBash">for</code> :
</p>
<button onclick="myToggle('lab4_exemplul1_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_exemplul1_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v3.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v3.sh">here</a>.</div>
</pre>

<p>
<b>iv)</b> A patra soluție: <tt class="stil_demo_filename">FirstScript_v4.sh</tt> -- 
încercăm o altă idee: putem oare să scriem ceva de forma $$i ? Adică ceva care să producă o dublă substituție ?
<br>
Răspunsul este afirmativ, se poate folosi comanda internă <code class="stil_cmdBash">eval</code> (a se revedea exemplul din
prezentarea practică amintită la începutul acestui suport de laborator), în felul următor:
</p>
<button onclick="myToggle('lab4_exemplul1_4')">Show / Hide the 4th version of this script</button>
<pre id="lab4_exemplul1_4" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v4.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v4.sh">here</a>.</div>
</pre>

<p>
<b>v)</b> A cincea soluție: <tt class="stil_demo_filename">FirstScript_v5.sh</tt> --
tot cu efect de dublă substituție se poate folosi o altă formă specială de <i>parameter expansion</i> a interpretorului
<tt>bash</tt>, și anume forma sintactică <tt class="stil_cmdBash">{!variabila}</tt> :
</p>
<button onclick="myToggle('lab4_exemplul1_5')">Show / Hide the 5th version of this script</button>
<pre id="lab4_exemplul1_5" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v5.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v5.sh">here</a>.</div>
</pre>
<p>
<i>Explicație</i>: observați mai sus folosirea construcției <tt class="stil_cmdBash">${!i}</tt> care are ca efect o dublă substituție:
întâi se substituie {!i} cu valoarea variabilei i, rezultând un număr k (cuprins între 1 și numărul total de parametri de la apelul scriptului),
iar apoi se substituie $k cu valoarea celui de-al k-lea parametru de la apelul scriptului.
</p>

<p>
<b>vi)</b> A șasea soluție: <tt class="stil_demo_filename">FirstScript_v6.sh</tt> --
tot pentru calcule aritmetice se poate folosi o altă formă specială de substituție, numită <i>arithmetic expansion</i>,
a interpretorului <tt>bash</tt>, și anume forma sintactică <code class="stil_cmdBash">$((<i>expresie-aritmetică</i>))</code>,
care este prezentă și în interpretorul <tt>dash</tt> :
</p>
<button onclick="myToggle('lab4_exemplul1_6')">Show / Hide the 6th version of this script</button>
<pre id="lab4_exemplul1_6" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FirstScript_v6.sh">See the script from <a target="_blank" href="demo/lab4/FirstScript_v6.sh">here</a>.</div>
</pre>
<p>
Iată și câteva exemple de execuție a acestui script în <i>foreground</i>:
<br>
<button onclick="myToggle('lab4_exemplul1_6_1')">Show / Hide some examples of running this script in foreground</button>
<div id="lab4_exemplul1_6_1" class="stil_hidden-text_level1">
Astfel, dacă vom executa scriptul prin prima formă de execuție în <i>foreground</i>,
el va fi executat de shellul <tt>/bin/dash</tt> și de această dată nu ne va da erori:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./FirstScript_v6.sh a bb ccc</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestui script:
<pre class="stil_output">
param_1 = a
param_2 = bb
param_3 = ccc
</pre>
Iar dacă dorim să executăm scriptul cu ajutorul shellului <tt>/bin/bash</tt>, putem face aceasta
apelându-l prin a doua formă de execuție a unei comenzi în <i>foreground</i>:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> /bin/bash FirstScript_v6.sh a b c d</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
param_1 = a
param_2 = b
param_3 = c
param_4 = d
</pre>
</div>
</p>
</div>
<br><br>
</li>


<li><!-- Problema: lab5_ex3.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyExpr]</span>
<br>
Să se scrie un script care să efectueze într-o buclă pașii următori:
<ol>
<li> citește de la tastatură două numere și un operator + , - , * sau / </li>
<li> efectuează operația respectivă </li>
<li> scrie rezultatul, pe o nouă linie, în cadrul unui fișier, sub forma: &nbsp;
  <tt style="color:blue;"><i> nr_operatie: operand1 operator operand2 = rezultat </i></tt>
</li>
<li> reia bucla </li>
</ol>
<br>
Din bucla respectivă se va ieși la introducerea caracterului 'q' pe poziția operatorului.
Înainte de terminare, se va scrie în fișier și numărul total de operații efectuate.
Numele fișierului în care se face scrierea se primește ca parametru în linia de comandă, sau se va citi prin comanda read în caz contrar.
</p>

<button onclick="myToggle('lab5_ex3')">Show / Hide a possible solution</button>
<div id="lab5_ex3" class="stil_rezolvare">
Ideea de rezolvare este să folosim o structură de control repetitivă pentru a implementa bucla cerută în enunț.
<p>
O soluție posibilă, ce folosește comanda internă <code class="stil_cmdBash">until</code>, ar fi următorul script:
</p>
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/MyExpr.sh">See the script from <a target="_blank" href="demo/lab4/MyExpr.sh">here</a>.</div>
</pre>
<i>Exercițiu</i>: încercați singuri să modificați acest script astfel încât să utilizeze comanda internă
<code class="stil_cmdBash">while</code> în locul comenzii interne <code class="stil_cmdBash">until</code>.
</div>

<p>
Iar acum vom considera o a doua variantă a acestei probleme, și anume vom extinde specificația ei astfel încât să ilustrăm și
următorii operatori aritmetici: "%" -- pentru restul împărțirii întregi, respectiv "**" -- pentru ridicarea la putere;
iar în cazul operatorului "/", vom afișa atât rezultatul împărțirii întregi, cât și rezultatul împărțirii reale.
</p>
<button onclick="myToggle('lab5_ex3_2')">Show / Hide the solution for the 2nd version of this problem</button>
<div id="lab5_ex3_2" class="stil_rezolvare">
Iată o posibilă soluție pentru această versiune extinsă a problemei inițiale:
<br>
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/MyExpr_v2.sh">See the script from <a target="_blank" href="demo/lab4/MyExpr_v2.sh">here</a>.</div>
</pre>
Iată și un posibil conținut al fișierului de output produs în urma unei execuții a acestui script:
<pre class="stil_output">
1:  4 * 2 = 8
2:  4 ** 2 = 16
3:  14 / 3 = 4 (impartire intreaga) si 4.66666666666666666666 (impartire reala)
4:  14 % 3 = 2
5:  5 + 10 = 15
6:  5 - 10 = -5
Numarul total de operatii efectuate: 6
</pre>
</div>
<br><br>
</li>


<li><!-- Problema: lab5_ex9.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyGccOrCat]</span>
<br>
Să se scrie un script care primește ca parametru un nume de director.
Scriptul va compila fiecare fișier sursă C aflat în directorul dat,
respectiv va tipări (i.e., afișa pe ecran) conținutul fiecărui fișier text din acest director.
(Compilarea se va realiza în felul următor: &nbsp; <code class="stil_cmdBash">gcc fisier.c -o fisier -Wall</code> .)
<br>
(<i>Atenție</i>: NU se cere parcurgerea recursivă a directorului respectiv!)
</p>

<button onclick="myToggle('lab5_ex9')">Show / Hide a possible solution</button>
<div id="lab5_ex9" class="stil_rezolvare">
<!--O posibilă soluție este următoarea:-->
O soluție posibilă, ce ilustrează și modul de utilizare a funcțiilor <i>shell</i>, ar fi următorul script:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/MyGccOrCat.sh">See the script from <a target="_blank" href="demo/lab4/MyGccOrCat.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>:
<div class="stil_hidden-text_level1_small-padding">Dacă veți testa scriptul acesta cu un director
în care se găsesc și fișiere care conțin în numele lor caractere ce sunt spații sau tab-uri,
atunci pentru respectivele fișiere veți obține erori de genul "File not found",
datorită modului de evaluare a enumerării din
structura <code class="stil_cmdBash">for <i>variabila</i> in <i>lista-de-cuvinte</i></code> ,
ceea ce face imposibilă protejarea spațiilor din numele fișierelor și subdirectoarelor obținute
cu comanda <code class="stil_cmdBash">ls -A</code> &nbsp;
(sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
&nbsp; &nbsp;
Mai multe detalii despre acest subiect, precum și o idee de tratare a acestor nume "excepționale" de fișiere,
veți putea afla citind observația suplimentară de la finalul rezolvării exercițiului
<span class="stil_ref_ex">[MyFind #1]</span> din suportul de laborator de săptămâna viitoare.
</div>
</p>
</div>
<br><br>
</li>

<p class="stil_observatie_level0">
<b><i>Observație importantă</i></b>:
în exemplele ce urmează mai jos, la punctele b) și c), ne vom concentra atenția pe ilustrarea diferitelor construcții sintactice și comenzi interne ale limbajului de <i>scripting</i> <tt>bash</tt>,
utilizând pentru aceasta implementarea în acest limbaj a unor algoritmi ușor de înțeles pe baza cunoștințelor dvs. anterioare, i.e. algoritmi ce efectuează diferite calcule matematice (iterative și recursive).
<br>
Rețineți însă faptul că obiectivul principal al acestui limbaj de <i>scripting</i> nu este acela de a face calcule matematice
(există alte limbaje de programare ce sunt mai adecvate pentru acest scop),
ci acela de a permite <b>automatizarea lucrului la linia de comandă</b> în sistemele de operare din familia Unix, cum ar fi de exemplu pentru execuția a diverse sarcini de administrare a sistemului, sau pentru manipularea resurselor sistemului (fișiere, procese, ș.a.).
<br>
În suportul de laborator de săptămâna viitoare vom ilustra o serie de script-uri care execută astfel de <b>operații de administrare / manipulare de resurse</b> ;
până atunci însă, în lecția de astăzi, concentrați-vă atenția pe însușirea sintaxei și semanticii limbajului
de <i>scripting</i> <tt>bash</tt>. 
</p>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b2">b) <span class="stil_ex_rezolvate">Exemple de <i>script</i>-uri ce efectuează diverse calcule matematice iterative</span> :</p>


<li><!-- Problema: lab4_ex4.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Iterative math #1]</span>
<br>1) Să se scrie un script care să efectueze calculul produsului n * m prin adunări repetate (i.e.,
<span class="stil_black_BGcolor"><tt>&nbsp; n * m = n + n + ... + n, de m ori &nbsp;</tt></span> ).
<br>
<small>(Indicație: <span class="stil_hint2">valorile pentru n și m se vor prelua ca argumente din linia de comandă prin care se lansează scriptul,
sau se vor citi cu comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
<br>
2) Să se scrie un script care să efectueze calculul puterii n la m prin înmulțiri repetate.
<br>
<small>(Indicație: <span class="stil_hint2">valorile pentru n și m se vor prelua ca argumente din linia de comandă prin care se lansează scriptul,
sau se vor citi cu comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex4')">Show / Hide the solutions</button>
<div id="lab4_ex4" class="stil_rezolvare">
<dl>
<dt><b>1)</b> Ideea de rezolvare este să folosim o structură de control iterativă pentru a face adunări repetate.
Aceasta o putem face în mai multe moduri, și anume:
</dt>
<dd>
<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">Product_v1.sh</tt> --
folosim o structură repetitivă <code class="stil_cmdBash">for</code> și comanda internă <code class="stil_cmdBash">let</code> pentru calcule aritmetice:
</p>
<button onclick="myToggle('lab4_ex4_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex4_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Product_v1.sh">See the script from <a target="_blank" href="demo/lab4/Product_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">Product_v2.sh</tt>,
este o rescriere echivalentă a primei soluții, folosind o structură repetitivă <code class="stil_cmdBash">while</code>
în loc de <code class="stil_cmdBash">for</code>, plus alte mici diferențe sintactice:
</p>
<button onclick="myToggle('lab4_ex4_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex4_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Product_v2.sh">See the script from <a target="_blank" href="demo/lab4/Product_v2.sh">here</a>.</div>
</pre>

<p>
<b>iii)</b> A treia soluție: <tt class="stil_demo_filename">Product_v3.sh</tt>,
este o rescriere echivalentă a soluției anterioare, cu unele mici diferențe sintactice --
observați forma scurt-circuitată a operatorilor aritmetici de la comenzile <code class="stil_cmdBash">let</code>:
</p>
<button onclick="myToggle('lab4_ex4_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex4_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Product_v3.sh">See the script from <a target="_blank" href="demo/lab4/Product_v3.sh">here</a>.</div>
</pre>

<p>
<b>iv)</b> A patra soluție: <tt class="stil_demo_filename">Product_v4.sh</tt>,
este o rescriere echivalentă a soluțiilor anterioare, cu unele mici diferențe sintactice --
observați scrierea directă a operațiilor aritmetice, fără comenzi <code class="stil_cmdBash">let</code>,
lucru posibil datorită declarațiilor de tip întreg pentru variabilele respective:
</p>
<button onclick="myToggle('lab4_ex4_4')">Show / Hide the 4th version of this script</button>
<pre id="lab4_ex4_4" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Product_v4.sh">See the script from <a target="_blank" href="demo/lab4/Product_v4.sh">here</a>.</div>
</pre>

<p>
<i>Observație</i>: cele de mai sus sunt doar 4 soluții posibile, însă se mai pot scrie multe alte variante de rezolvare,
e.g. folosind bucla <code class="stil_cmdBash">for((</code> sau bucla <code class="stil_cmdBash">until</code>,
respectiv folosind și celelalte comenzi pentru calcule cu expresii aritmetice.
</p>
</dd>

<dt><b>2)</b> Ideea de rezolvare este similară cu cea de la pct.1), i.e. folosirea unei structuri de control iterative pentru a face înmulțiri repetate.
Aceasta o putem face în mai multe moduri, la fel ca la pct.1).
</dt>
<dd>
<p>
Voi ilustra doar una dintre soluții:
</p>
<button onclick="myToggle('lab4_ex4_5')">Show / Hide the second script</button>
<pre id="lab4_ex4_5" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Power.sh">See the script from <a target="_blank" href="demo/lab4/Power.sh">here</a>.</div>
</pre>

<p>
<i>Exercițiu</i>: încercați singuri celelalte soluții echivalente, obținute prin simpla înlocuire a operatorului + cu operatorul * și
a inițializării cu 1 în loc de 0 în celelalte variante de rezolvare a pct.i) pe care le-am prezentat mai sus.
</p>
</dd>
</dl>
</div>
<br><br>
</li>


<p>
<big>Iată alte câteva exerciții similare cu exemplul <span class="stil_ref_ex">[Iterative math #1]</span>, i.e.
exemple de <i>script</i>-uri ce efectuează diverse calcule matematice, într-o manieră iterativă.</big>
<br>
<i>Notă</i>: voi prezenta, uneori, doar câte o singură soluție pentru fiecare dintre aceste exerciții,
cu observația că puteți scrie diverse alte soluții echivalente,
făcând diverse modificări logice și/sau sintactice, precum cele exemplificate în soluțiile prezentate mai sus
în exemplul <span class="stil_ref_ex">[Iterative math #1]</span>.
<br><br>
</p> 


<li><!-- Problema: lab4_ex5.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Iterative math #2]</span>
<br>Să se scrie un script care să calculeze media aritmetică a n numere.
<br>
<small>(Indicație: <span class="stil_hint2">valorile pentru n și pentru cele n numere vor fi preluate ca argumente la linia de comandă prin care se lansează scriptul,
sau se vor citi cu comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex5')">Show / Hide the solutions</button>
<div id="lab4_ex5" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție, incorectă -- folosim comanda internă <code class="stil_cmdBash">let</code>, dar <u>calculul nu este exact!</u>
(deoarece comanda <code class="stil_cmdBash">let</code> lucrează doar cu numere întregi și operatorul <tt class="stil_cmdBash">/</tt> face doar împărțire întreagă):
</p>
<button onclick="myToggle('lab4_ex5_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex5_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/ArithmeticMean_v1.sh">See the script from <a target="_blank" href="demo/lab4/ArithmeticMean_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> A doua soluție, incompletă -- folosim comanda <code class="stil_cmdBash">bc</code> cu opțiunea -l pentru calcule în virgulă mobilă:
</p>
<button onclick="myToggle('lab4_ex5_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex5_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/ArithmeticMean_v2.sh">See the script from <a target="_blank" href="demo/lab4/ArithmeticMean_v2.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: <tt class="stil_cmdBash">scale=5</tt> (re)definește variabila scale, utilizată de comanda <code class="stil_cmdBash">bc</code>
pentru a lucra, în acest exemplu, cu numere cu 5 cifre zecimale după virgulă.
</p>

<p>
<b>iii)</b> A treia soluție, completă -- adăugăm la soluția anterioară și citirea numerelor de la tastatură,
pentru situațiile în care acestea nu se dau în linia de comandă:
</p>
<button onclick="myToggle('lab4_ex5_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex5_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/ArithmeticMean_v3.sh">See the script from <a target="_blank" href="demo/lab4/ArithmeticMean_v3.sh">here</a>.</div>
</pre>
</div>
<br><br>
</li>


<li><!-- Problema: lab4_ex6.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Iterative math #3]</span>
<br>Să se scrie un script care să calculeze valorile minimă și maximă ce apar într-o secvență de numere specificată,
fie ca argumente în linia de comandă, fie de la tastatură.
<br>
<small>(Indicație: <span class="stil_hint2">valorile numerice se vor citi prin comanda read, dacă nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex6')">Show / Hide the solutions</button>
<div id="lab4_ex6" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție, incompletă -- minimul și maximul se calculează printr-o singură parcurgere a secvenței de numere, dată în linia de comandă:
</p>
<button onclick="myToggle('lab4_ex6_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex6_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/MinMax_v1.sh">See the script from <a target="_blank" href="demo/lab4/MinMax_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> A doua soluție, completă -- adăugăm la soluția anterioară și citirea numerelor de la tastatură,
în cazul în care acestea nu se dau în linia de comandă:
</p>
<button onclick="myToggle('lab4_ex6_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex6_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/MinMax_v2.sh">See the script from <a target="_blank" href="demo/lab4/MinMax_v2.sh">here</a>.</div>
</pre>
</div>
<br><br>
</li>


<li><!-- Problema: lab4_ex8.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Iterative math #4]</span>
<br>Să se scrie un script care să calculeze valoarea numerică ce apare de cele mai multe ori, precum și numărul ei de apariții,
în șirul de valori numerice date ca argumente în linia de comandă.
<br>
<small>(Indicație: <span class="stil_hint2">valorile numerice se vor citi prin comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex8')">Show / Hide a possible solution</button>
<div id="lab4_ex8" class="stil_rezolvare">
<p>
Iată o posibilă soluție -- observați folosirea <b>variabilelor de tip tablou</b> (i.e.,
modul de declarare și de referire la valoarea unui element din tablou) în scriptul de mai jos:
</p>
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/FrequencyVector.sh">See the script from <a target="_blank" href="demo/lab4/FrequencyVector.sh">here</a>.</div>
</pre>
</div>
<br><br>
</li>


<li><!-- Problema: lab4_ex9.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Iterative math #5]</span>
<br>Să se scrie un script care să calculeze C(n,k) (i.e., combinări de n luate câte k).
<br>
<small>(Indicație: <span class="stil_hint2">valorile n și k se vor prelua ca argumente din linia de comandă prin care se lansează scriptul,
sau se vor citi prin comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex9')">Show / Hide the solutions</button>
<div id="lab4_ex9" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">Combinatorial_v1.sh</tt> --
folosim o funcție auxiliară, care va calcula n!,
iar calculul combinărilor se va face pe baza formulei <span class="stil_black_BGcolor"><tt>&nbsp; C(n,k) = n! / (k!*(n-k)!) &nbsp;</tt></span> :
</p>
<button onclick="myToggle('lab4_ex9_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex9_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Combinatorial_v1.sh">See the script from <a target="_blank" href="demo/lab4/Combinatorial_v1.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: pentru a inhiba afișarea pe ecran a mesajelor de depanare (i.e. cele ce afișează rezultatele intermediare),
puteți fie să comentați/ștergeți liniile respective din script,
fie puteți să lansați scriptul în execuție cu fluxul standard pentru ieșirea de eroare redirectat către fișierul null, adică astfel:
<br>
<tt>UNIX> </tt><code class="stil_cmdBash">./Combinatorial.sh  N  K  2> /dev/null</code>
</p>

<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">Combinatorial_v2.sh</tt> --
este similară cu prima, doar că am făcut "inline" calculul efectuat de funcția fact() în soluția anterioară:
</p>
<button onclick="myToggle('lab4_ex9_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex9_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Combinatorial_v2.sh">See the script from <a target="_blank" href="demo/lab4/Combinatorial_v2.sh">here</a>.</div>
</pre>

<p>
<b>iii)</b> A treia soluție: <tt class="stil_demo_filename">Combinatorial_v3.sh</tt> --
calculul se face cu o singură buclă iterativă, pe baza formulei simplificate
<span class="stil_black_BGcolor"><tt>&nbsp; C(n,k) = n! / (k!*(n-k)!) = ( (n-k+1)*(n-k+2)*...*n ) / ( 1*2*3*...*k ) &nbsp;</tt></span> :
</p>
<button onclick="myToggle('lab4_ex9_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex9_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Combinatorial_v3.sh">See the script from <a target="_blank" href="demo/lab4/Combinatorial_v3.sh">here</a>.</div>
</pre>
</div>
<br><br>
</li>


<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b3">c) <span class="stil_ex_rezolvate">Exemple de <i>script</i>-uri ce efectuează diverse calcule matematice recursive</span> :</p>


<li><!-- Problema: lab4_ex14.sh ------------------------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[Recursive math #1]</span>
<br>Să se scrie un script care să efectueze calculul recursiv al factorialului (i.e.,
<span class="stil_black_BGcolor"><tt>&nbsp; n! = n * (n-1)!, pentru n > 0, respectiv 0! = 1 &nbsp;</tt></span> ).
<br>
<small>(Indicație: <span class="stil_hint2">valoarea pentru n se va prelua ca argument din linia de comandă prin care se lansează scriptul,
sau se va citi cu comanda read, în caz că nu este dată în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex14')">Show / Hide the solutions</button>
<div id="lab4_ex14" class="stil_rezolvare">
Ideea de rezolvare -- avem următoarele posibilități de implementare:
<ul>
<li><b>Recursia</b> se poate implementa în două maniere diferite, exemplificate în soluțiile ce urmează a fi prezentate mai jos:
<br>a) fie prin <i>apel recursiv de funcție</i> (a se vedea primele 4 soluții de mai jos),
<br>b) fie prin <i>apel recursiv de procedură/script</i> (a se vedea celelalte soluții de mai jos),
iar în acest caz trebuie să ținem cont și de modul de apel, i.e.
dacă vor fi executate toate apelurile de aceeași instanță de shell, caz în care avem "memorie comună" între apeluri,
sau fiecare apel va fi executat de o nouă instanță a shell-ului, caz în care NU mai avem variabile partajate între apeluri.
<br><br>
</li>
<li><b>Valoarea intermediară</b> a calculului efectuat în manieră recursivă se poate transmite de la un apel la altul prin mai multe modalități;
în cele de mai jos sunt ilustrate patru dintre acestea:
<br>i) fie prin codul de terminare a procesului (a se vedea prima soluție de mai jos),
<br>ii) fie prin "preluarea", în linia de comandă a apelantului, a valorii afișate pe ecran de apelat (a se vedea a doua soluție de mai jos),
<br>iii) fie printr-o variabilă globală (a se vedea a patra soluție de mai jos),
<br>iv) fie printr-un al doilea parametru de apel al funcției/scriptului (a se vedea a treia soluție de mai jos).
<br>  
<i>Notă</i>: varianta i) este foarte limitată, căci permite transmiterea unei singure valori, iar aceasta este restricționată la un octet fără semn.
Celelalte variante pot fi folosite și atunci când avem de transmis mai multe valori de la un apel la altul (e.g.,
pentru calculul unei relații de recurență de ordinul 2, sau mai mare).
</li>
</ul>

<p>
<b>1)</b> Prima soluție: <tt class="stil_demo_filename">Factorial_v1.sh</tt> --
scriem o funcție recursivă și returnăm rezultatul calculat de un apel al funcției prin codul de terminare a procesului:
</p>
<button onclick="myToggle('lab4_ex14_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex14_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v1.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v1.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: comanda <code class="stil_cmdBash">return nr</code> provoacă terminarea execuției funcției, cu <tt>nr</tt> drept cod de terminare.
Iar cu variabila specială <tt class="stil_cmdBash">$?</tt> putem afla codul de terminare
al ultimei comenzi (în particular, apel de funcție) ce a fost executat(ă) anterior comenzii în care consultăm valoarea acestei variabile speciale.
</p>
<p>
<i>Atenție</i>: un apel de funcție în <tt>bash</tt> NU are aceeași semnificație ca în limbajul C,
i.e. apelul nu poate apare ca operand într-o expresie,
ci poate apare doar în pozițiile în care sunt permise nume de comenzi în cadrul unei linii de comandă, sau al unei linii dintr-un fișier de comenzi.
<i>Practic, numele funcției este ca un "alias" pentru lista de comenzi din corpul funcției</i>!
</p>
<p>
<i>Observație importantă</i>: codul de terminare a procesului se reprezintă pe un singur octet, fără semn,
și ca atare această soluție nu afișează valorile corecte ale factorialului pentru n > 5 (fiindcă apare depășire la octet)!!!
</p>

<p>
<b>2)</b> A doua soluție: <tt class="stil_demo_filename">Factorial_v2.sh</tt> --
folosim ideea cu funcția recursivă de mai sus, dar rezultatul calculat de un apel al funcției îl afișăm pe ecran
în corpul funcției și îl recuperăm în afara ei prin substituția specială comandă:
</p>
<button onclick="myToggle('lab4_ex14_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex14_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v2.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v2.sh">here</a>.</div>
</pre>

<p>
<b>3)</b> A treia soluție: <tt class="stil_demo_filename">Factorial_v3.sh</tt> --
folosim tot o funcție recursivă ca mai sus, dar rezultatul calculat de un apel al funcției
îl transmitem la apelul următor prin intermediul unui al doilea parametru al funcției:
</p>
<button onclick="myToggle('lab4_ex14_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex14_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v3.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v3.sh">here</a>.</div>
</pre>

<p>
<b>4)</b> A patra soluție: <tt class="stil_demo_filename">Factorial_v4.sh</tt> --
folosim tot o funcție recursivă ca mai sus, dar rezultatul intermediar calculat de un apel al funcției
îl transmitem la apelul următor prin intermediul unei variabile (variabila cu numele rez de mai jos):
</p>
<button onclick="myToggle('lab4_ex14_4')">Show / Hide the 4th version of this script</button>
<pre id="lab4_ex14_4" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v4.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v4.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: cele două comenzi <code class="stil_cmdBash"> echo "----- ... -----" 1>&amp;2 </code> ,
ce afișează mesaje pe ieșirea standard de eroare <tt>stderr</tt> , au doar un rol ajutător: pentru a putea observa ordinea "în stivă" a apelurilor succesive.
<br>
Pentru a inhiba apariția acestor mesaje, este suficient să rulați acest script cu ieșirea de eroare standard redirectată către fișierul null, adică:
<br>
<tt>UNIX> </tt><code class="stil_cmdBash">./Factorial.sh  N  2> /dev/null</code>
<br>
Similar, puteți adăuga astfel de mesaje ajutătoare și la soluțiile anterioare.
</p>

<p>
<i>Observație importantă</i>: cele patru soluții de mai sus folosesc o funcție recursivă, i.e. care se re-apelează.
Aplicând varianta b) de implementare a recursiei, se pot scrie alte patru soluții similare d.p.d.v. al transmiterii valorilor intermediare,
dar fără a utiliza funcții recursive, ci însuși scriptul fiind cel care se re-apelează.
</p>

<p>
<b>5)</b> A cincea soluție: <tt class="stil_demo_filename">Factorial_v5.sh</tt> --
spre exemplificare, iată o rescriere a primei soluții, folosind un apel recursiv al scriptului:
</p>
<button onclick="myToggle('lab4_ex14_5')">Show / Hide the 5th version of this script</button>
<pre id="lab4_ex14_5" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v5.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v5.sh">here</a>.</div>
</pre>
<p>
<i>Atenție</i>: aceasta are același dezavantaj ca și prima soluție -- codul de terminare a procesului se reprezintă pe un octet, fără semn,
și ca atare aceasta soluție nu afișează valorile corecte ale factorialului pentru n > 5 (fiindcă apare depășire la octet)!!!
</p>
<p>
<i>Observația #1</i>: varianta aceasta de script presupune apelarea sa printr-una dintre primele două forme de apel, i.e.
&nbsp; <tt>UNIX> </tt><code class="stil_cmdBash">./Factorial.sh  [N]</code>
&nbsp; sau
&nbsp; <tt>UNIX> </tt><code class="stil_cmdBash">bash Factorial.sh  [N]</code> &nbsp;.
Dacă doriți să apelați scriptul acesta prin cea de-a treia formă de apel, i.e.
&nbsp; <tt>UNIX> </tt><code class="stil_cmdBash">source Factorial.sh  [N]</code> &nbsp;,
atunci va trebui să înlocuiți <tt>$0</tt> din linia ce conține apelul recursiv,
cu numele exact pe care l-ați dat fișierului în care ați salvat scriptul respectiv.
(Motivul fiind acela că la cea de-a treia formă de apel, valoarea lui <tt>$0</tt> nu mai este numele scriptului,
ci numele instanței de <i>shell</i> care-l rulează.)
</p>
<p>
<i>Observația #2</i>: un alt aspect este forma de apelare a scriptului în linia din acesta ce conține apelul recursiv.
Și aici am putea utiliza cele trei forme de apel. După cum observați, am folosit a doua formă.
Se mai poate folosi și prima formă, dar nu și a treia formă, fără să mai fac și alte modificări în script.
Motivul este că în cazul folosirii primei sau a celei de-a doua forme de apel, fiecare apel creează un nou proces,
ce va rula o instanță de <tt>bash</tt> care va executa acel apel recursiv al scriptului,
iar revenirea din apelul recursiv se face prin acea comandă exit, prin care se încheie execuția acelei instanțe de <tt>bash</tt>
(și, în plus, furnizează și rezultatul intermediar prin codul de terminare al acelei instanțe).
În schimb, dacă s-ar folosi a treia formă de apel, aceasta nu mai creează câte un nou proces <tt>bash</tt> la fiecare apel recursiv,
ci un singur proces, i.e. instanța inițială de <tt>bash</tt>, va "încerca" să execute toate apelurile scriptului,
dar va eșua din cauza comenzii exit.
</p>

<p>
<b>6)</b> A șasea soluție: <tt class="stil_demo_filename">Factorial_v6.sh</tt> --
spre exemplificare, iată și o rescriere a celei de a doua soluții, folosind un apel recursiv al scriptului:
</p>
<button onclick="myToggle('lab4_ex14_6')">Show / Hide the 6th version of this script</button>
<pre id="lab4_ex14_6" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Factorial_v6.sh">See the script from <a target="_blank" href="demo/lab4/Factorial_v6.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: și în acest caz sunt valabile observațiile de la varianta precedentă, referitoare la modul de apelare a scriptului.
</p>
<p>
<i>Important</i>: similar se pot rescrie și soluțiile (cu funcții recursive) a 3-a și a 4-a de mai sus,
modificându-le în script-uri care se re-apelează recursiv.
&nbsp; Ca și exercițiu, încercați să faceți singuri aceste modificări!
</p>
</div>
<br><br>
</li>


<li><!-- Problema: lab4_ex-new1.sh --------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Recursive math #2]</span>
<br>Să se scrie un script care primește două valori de intrare, n și m, și verifică în manieră recursivă dacă numărul n este o 
putere a numărului m, afișând la final 'Adevărat' sau, respectiv, 'Fals', după caz.
<br>
<small>(Indicație: <span class="stil_hint2">valorile pentru n și m se vor prelua ca argumente din linia de comandă prin care se lansează scriptul,
sau se vor citi cu comanda read, în caz că nu sunt date în linia de comandă.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex-new1')">Show / Hide the solution</button>
<div id="lab4_ex-new1" class="stil_rezolvare">
Ideea de rezolvare -- împărțim pe n la m în mod repetat (recursiv) până fie obținem un rest nenul, fie obținem câtul 1.
<p>
La fel ca la exercițiul precedent, putem combina după dorință cele 2x4 posibilități de implementare.
<br>Spre exemplificare,
iată o soluție ce folosește o funcție recursivă și cu transmiterea valorilor printr-o variabilă globală (pentru rezultatul final)
combinat cu transmiterea prin parametrii de apel ai funcției (pentru valoarea intermediară a n-ului):
</p>
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/IsPower.sh">See the script from <a target="_blank" href="demo/lab4/IsPower.sh">here</a>.</div>
</pre>
<p>
<i>Exercițiu</i>: încercați să scrieți singuri (măcar o parte dintre) soluțiile ce se bazează pe celelalte modalități de implementare
prezentate mai sus în exemplul <span class="stil_ref_ex">[Recursive math #1]</span>.
</p>
</div>
<br><br>
</li>



<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b4">d) <span class="stil_ex_rezolvate">Exemple de <i>script</i>-uri <b>cooperante</b>, ce efectuează diverse calcule matematice</span> :</p>


<li><!-- Problema: cooperating_1st_example-2024 ------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[Cooperating iterative math #1]</span>
<br>Să se scrie două scripturi care să efectueze în manieră <b>colaborativă</b> calculul iterativ descris mai sus
în exemplul <span class="stil_ref_ex">[Iterative math #1]</span>.
<b>Modalitatea exactă de colaborare</b> pentru realizarea acestui calcul este descrisă în cele ce urmează:
<ul>
<li>primul script, numit "producer.sh", va prelua valorile pentru n și m ca argumente din linia de comandă prin care se lansează scriptul, sau le va citi cu comanda read, în caz că nu sunt date în linia de comandă.
<br>
Apoi va verifica dacă ambele numere au același semn (i.e., sunt simultan pozitive, sau simultan strict negative),
caz în care le va "transmite" fără semn (i.e., în valoare absolută) către al doilea script,
folosind unul dintre mecanismele posibile de comunicație ce vor fi descrise mai jos.
Iar dacă cele două numere au semne contrare (i.e., unul este pozitiv, iar celălalt este strict negativ), atunci le va "transmite" către al doilea script într-o ordine posibil schimbată, astfel încât al doilea număr transmis să fie cel pozitiv.
<br>
Iar apoi primul script va apela (fie din script, fie din linia de comandă prin care este rulat)
al doilea script și (se) va afișa codul de exit al acestuia.
</li>
<li>al doilea script, numit "consumer.sh", va prelua cele două numere "transmise" de primul script,
și, în caz de excepții, se va termina cu codul de exit 1 (dacă nu "recepționează" două numere)
sau, respectiv, 2 (dacă al doilea număr "recepționat" este strict negativ).
<br>
Altfel, va face calculul iterativ descris mai sus în exemplul <span class="stil_ref_ex">[Iterative math #1]</span>,
afișând la final rezultatul calculat și se va termina cu codul de exit 0.
</li>
</ul>
<br>
Sunt posibile mai multe <b>mecanisme de comunicație</b> între cele două script-uri, prin "memorie comună" sau prin "schimb de mesaje", alegerea vreunuia dintre ele depinzând și de <b>modul de apelare</b> a celor două scripturi (!).
În cele de mai jos vor fi ilustrate doar două dintre aceste mecanisme de comunicație și moduri de apelare,
dar rețineți faptul că pot fi implementate/utilizate și altele.
</p>

<button onclick="myToggle('lab4_ex1cooperant')">Show / Hide the solutions</button>
<div id="lab4_ex1cooperant" class="stil_rezolvare">
<dl>
<dt><b>1)</b> O primă posibilitate de implementare este ca al doilea script să fie apelat din primul script, 
prin prima sau a doua formă de apelare în foreground.
În acest caz, cele două scripturi vor fi executate în două procese diferite (i.e., două instanțe distincte ale
interpretorului <tt>bash</tt>), deci fără memorie comună între ele.
Atunci putem folosi o variabilă de mediu, definită în primul script și citită în al doilea, pentru a transmite informațiile dorite de la primul script către al doilea.
<br>
Această idee poate fi implementată în felul următor:
</dt>
<dd>
<p>
<b>i)</b> Primul script: <tt class="stil_demo_filename">Producer_v1.sh</tt> --
folosim o structură alternativă <code class="stil_cmdBash">if [ ... ]</code> pentru testele de efectuat
și comanda <code class="stil_cmdBash">export</code> pentru definirea variabile de mediu necesare pentru comunicație:
</p>
<button onclick="myToggle('lab4_ex1cooperant_1_1')">Show / Hide the 1st script</button>
<pre id="lab4_ex1cooperant_1_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Producer_v1.sh">See the script from <a target="_blank" href="demo/lab4/Producer_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> Al doilea script: <tt class="stil_demo_filename">Consumer_v1.sh</tt>,
extragem cele două valori din variabila de mediu exportată de primul script, iar pentru efectuarea calculelor
putem folosi o structură repetitivă <code class="stil_cmdBash">for</code> sau celelalte idei echivalente prezentate
în exemplul <span class="stil_ref_ex">[Iterative math #1]</span> :
</p>
<button onclick="myToggle('lab4_ex1cooperant_1_2')">Show / Hide the 2nd script</button>
<pre id="lab4_ex1cooperant_1_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Consumer_v1.sh">See the script from <a target="_blank" href="demo/lab4/Consumer_v1.sh">here</a>.</div>
</pre>

<p>
Exemple de execuție a celor două script-uri cooperante:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v1.sh 2 3</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei 2 * 3 este: 6
[Producer.sh] Codul de exit din scriptul Consumer este: 0
</pre>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v1.sh -2 3</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei -2 * 3 este: -6
[Producer.sh] Codul de exit din scriptul Consumer este: 0
</pre>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v1.sh -2 -3</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei 2 * 3 este: 6
[Producer.sh] Codul de exit din scriptul Consumer este: 0
</pre>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v1.sh 2 -3</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei -2 * 3 este: -6
[Producer.sh] Codul de exit din scriptul Consumer este: 0
</pre>
</p>
</dd>
<p>
<i style="color:red;">Observație</i>: o variațiune a acestei prime posibilități de implementare ar consta în faptul ca al doilea script să fie apelat din primul script prin cea de a treia formă de apelare în foreground (i.e., cu <tt>source</tt>).
În acest caz, cele două scripturi vor fi executate în același proces (i.e., aceeași instanță de execuție a
interpretorului <tt>bash</tt>), deci vor avea memorie comună între ele,
i.e. variabilele n și m definite în primul script vor fi "vizibile" și în al doilea script.
Ca urmare, nu mai este necesară folosirea unei variabile de mediu, definită în primul script și citită în al doilea, pentru a transmite informațiile dorite de la primul script către al doilea.
<br>
Vă las ca temă pentru acasă să efectuați singuri modificările necesare în scripturile de mai sus pentru a transpune în practică această variațiune de implementare.
</p>
<br><br>


<dt><b>2)</b> O a doua posibilitate de implementare este ca ambele scripturi să fie apelate printr-o singură linie de comandă, construind o comandă compusă cu unul dintre operatorii sintactici de compunere a comenzilor simple.
Spre exemplu, dacă folosim operatorul de execuție paralelă și înlânțuită, atunci vom utiliza mecanismul de comunicație implicit al acestui operator pentru a transmite informațiile dorite de la primul script către al doilea.
<br>
Această idee poate fi implementată în felul următor:
</dt>
<dd>
<p>
<b>i)</b> Primul script: <tt class="stil_demo_filename">Producer_v2.sh</tt> --
folosim o structură alternativă <code class="stil_cmdBash">if [ ... ]</code> pentru testele de efectuat,
iar pentru a realiza comunicația prin înlănțuirea cu al doilea script, este suficient să afișăm pe fluxul <tt>stdout</tt>
informațiile ce trebuie transmise către acesta:
</p>
<button onclick="myToggle('lab4_ex1cooperant_2_1')">Show / Hide the 1st script</button>
<pre id="lab4_ex1cooperant_2_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Producer_v2.sh">See the script from <a target="_blank" href="demo/lab4/Producer_v2.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> Al doilea script: <tt class="stil_demo_filename">Consumer_v2.sh</tt>,
pentru a realiza comunicația prin înlănțuirea cu primul script,
este suficient să citim cele două valori din fluxul <tt>stdin</tt>, iar pentru efectuarea calculelor
putem folosi o structură repetitivă <code class="stil_cmdBash">for</code> sau celelalte idei echivalente prezentate
în exemplul <span class="stil_ref_ex">[Iterative math #1]</span> :
</p>
<button onclick="myToggle('lab4_ex1cooperant_2_2')">Show / Hide the 2nd script</button>
<pre id="lab4_ex1cooperant_2_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Consumer_v2.sh">See the script from <a target="_blank" href="demo/lab4/Consumer_v2.sh">here</a>.</div>
</pre>

<p>
Exemple de execuție a celor două script-uri cooperante:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v2.sh 3 5 | ./Consumer_v2.sh ; echo "Codul de exit din scriptul Consumer este: $?"</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei 3 * 5 este: 15.
Codul de exit din scriptul Consumer este: 0
</pre>
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./Producer_v2.sh 3 -5 | ./Consumer_v2.sh ; echo "Codul de exit din scriptul Consumer este: $?"</code>
<br>
și urmărim outputul afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
[Consumer.sh] Rezultatul operatiei -3 * 5 este: -15.
Codul de exit din scriptul Consumer este: 0
</pre>
</p>
</dd>

</dl>
</div>
<br><br>
<i style="color:red;">Observație finală</i>: evident, calculul iterativ paralelizat în exemplul colaborativ prezentat mai sus este
mult prea simplu și, în practică, nu se justifică paralelizarea sa.
Scopul acestui exemplu a fost unul didactic, pentru a ilustra cum se pot scrie script-uri care să colaboreze pentru
a paraleliza un calcul, fără a complica însă prezentarea cu ilustrarea vreunui calcul matematic atât de complex,
încât să justifice paralelizarea sa în practică.
<br><br>
</li>



<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>

</ol>


<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:3px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1c">I.2) <span class="stil_ex_rezolvate">Corectarea unor greșeli ``strecurate'' într-un script dat</span> :</p>

<p>
În activitatea de programare într-un limbaj nou, este ușor să facem greșeli atunci când scriem un program, fiind "începători".
Prin urmare, ar trebui să învățăm și cum să detectăm eventualele greșeli pe care le facem, pentru a le corecta.
<br>
În cele de mai jos voi ilustra aceste lucruri, detecția și corecția erorilor de programare,
pentru cazul limbajului de <i>scripting</i> <tt>bash</tt>, i.e. un limbaj de programare interpretat, nu compilat! 
</p>
<p>
Pentru a detecta erorile ce s-au ``strecurat'' din greșeală într-un script, putem apela la următoarele două mijloace de detecție:
<ol>
<li>Folosirea atributului <tt>noexec</tt> al interpretorului <tt>bash</tt>, al cărei efect este următorul:
citește comenzile<!-- din script linie cu linie-->, dar fără să le execute.
<br>
Acest atribut (i.e., opțiune de execuție) al interpretorului <tt>bash</tt> poate fi utilizată pentru analiza sintactică a unui script,
i.e. pentru a verifica un script pentru erori de sintaxă.
<br>
Această analiză sintactică a unui script o putem invoca în două moduri diferite:
<ul>
<li>Apelăm interpretorul <tt>bash</tt> cu opțiunea <tt>-n</tt> pentru execuția scriptului
prin a doua formă de execuție în <i>foreground</i>, i.e. un apel de forma:
<br><tt>UNIX> </tt><code class="stil_cmdBash"> bash -n  <i>script.sh</i></code>
<!--
bash -n script.sh
Read commands but do not execute them. This may be used to check a shell script for syntax errors.
This is ignored by interactive shells.
-->
<br><br>
</li>
<li>Sau putem folosi comanda internă <code>set</code> a interpretorului <tt>bash</tt>
pentru a activa atributul <tt>noexec</tt>, precum am amintit în lecția practică.
<br>
Mai precis, activarea acestui atribut o facem cu comanda
<code class="stil_cmdBash"> set -o noexec</code> , sau forma prescurtată <code class="stil_cmdBash"> set -n</code> ,
comandă care se poate scrie fie la începutul scriptului (după prima linie cu interpretorul),
fie pe o altă linie din acel script, caz în care va avea efect de non-execuție doar asupra liniilor din script ce urmează după ea.
Iar apoi scriptul trebuie apelat prin prima sau a doua formă de execuție în <i>foreground</i>, i.e. un apel de forma:
<br><tt>UNIX> </tt><code class="stil_cmdBash"> ./<i>script.sh</i> [<i>parametri</i>]</code>
<br>sau
<br><tt>UNIX> </tt><code class="stil_cmdBash"> bash <i>script.sh</i> [<i>parametri</i>]</code>
<br>(<i>Notă</i>: apelarea prin forma a treia de execuție NU produce efectul scontat al atributului <tt>noexec</tt>,
căci în acest caz scriptul este executat de instanța de shell curentă,
nu se mai creează un nou proces shell ca în cazul primelor două forme de execuție.)
</li>
</ul>
<br><br>
</li>

<li>Nu toate erorile pot fi detectate doar prin citirea comenzilor, fără execuția lor.
Pentru a înțelege însă ce se va executa în urma "citirii" unei comenzi
(care presupune și efectuarea tuturor interpretărilor pentru diferitele construcții speciale ale limbajului),
putem folosi atributul <tt>xtrace</tt> al interpretorului <tt>bash</tt>, al cărei efect este următorul:
pentru fiecare comandă citită, se afișează mai întâi pe ecran rezultatul interpretării acelei comenzi,
iar apoi acest rezultat este executat efectiv.
<br>
Activarea acestei opțiuni de "depanare", despre care am amintit în lecția practică, se face cu comanda
<code class="stil_cmdBash"> set -o xtrace</code> , sau forma prescurtată <code class="stil_cmdBash"> set -x</code> ,
comandă care se poate scrie în mai multe locații posibile:
<ul>
<li>fie la începutul scriptului (după prima linie cu interpretorul),
fie pe o altă linie din acel script, caz în care va avea efect de "depanare" doar asupra liniilor din script ce urmează după ea.
Iar apoi scriptul trebuie apelat prin prima sau a doua formă de execuție în <i>foreground</i>, i.e. un apel de forma:
<br><tt>UNIX> </tt><code class="stil_cmdBash"> ./<i>script.sh</i> [<i>parametri</i>]</code>
<br>sau
<br><tt>UNIX> </tt><code class="stil_cmdBash"> bash <i>script.sh</i> [<i>parametri</i>]</code>
<br>(<i>Notă</i>: scriptul poate fi apelat și prin forma a treia de execuție,
dar în acest caz scriptul va fi executat de instanța de shell curentă,
nu se mai creează un nou proces shell ca în cazul primelor două forme de execuție.
Ca urmare, efectul comenzii de activare a opțiunii de "depanare" va rămâne persistent în instanța de shell curentă,
i.e. cea la a cărui prompter lucrăm. Pentru a o dezactiva, vedeți observația scrisă la cazul de mai jos.)
<br><br>
</li>
<li>fie se poate scrie chiar la prompter, i.e. la linia de comandă a shell-ului în care lucrăm și vom executa acel script,
activând astfel opțiunea de "depanare" pentru instanța de shell curentă.
Iar în acest caz scriptul trebuie apelat prin a treia formă de execuție în <i>foreground</i>, i.e. un apel de forma:
<br><tt>UNIX> </tt><code class="stil_cmdBash"> source <i>script.sh</i> [<i>parametri</i>]</code>
<br>(<i>Notă</i>: apelarea prin prima sau a doua formă de execuție NU produce efectul scontat al atributului <tt>xtrace</tt>,
căci în cazul primelor două forme de execuție se creează un nou proces shell care va executa scriptul,
prin urmare acesta NU va fi executat de instanța de shell curentă în care am activat opțiunea de "depanare".)
<br>
<i>Observație</i>: după ce am terminat activitatea de depanare a scriptului respectiv,
putem dezactiva opțiunea de "depanare" pentru instanța de shell curentă, pentru a scăpa de mesajele de depanare,
prin comanda <code class="stil_cmdBash"> set +o xtrace</code> , sau forma prescurtată <code class="stil_cmdBash"> set +x</code>,
scrisă la prompterul instanței de shell curente.
</li>
</ul>
</li>
</ol>
</p>

<p>
În exemplul de mai jos voi ilustra folosirea ambelor mijloace de detecție a erorilor dintr-un script.
</p>
<ol>

<li>
<p><span class="stil_titlu_ex">[Exemplul #1 de script cu erori]</span>
<br>
Se dă scriptul următor, care se va apela cu o serie de parametri în linia de comandă:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab4/Power_with_errors.sh">See the script from <a target="_blank" href="demo/lab4/Power_with_errors.sh">here</a>.</div>
</pre>
i) Explicați ce se va afișa pe ecran în urma execuției scriptului.
<br>
ii) Corectați eventualele erori (sintactice și semantice) existente în script astfel încât, în urma execuției scriptului corectat,
pe ecran să apară afișat rezultatul ridicării la putere ('primul parametru' la puterea 'al doilea parametru').
</p>

<button onclick="myToggle('lab4_ex-err1')">Show / Hide the solution</button>
<div id="lab4_ex-err1" class="stil_rezolvare" w3-include-HTML="demo/lab4/Power_with_errors.html">See
the page from <a target="_blank" href="demo/lab4/Power_with_errors.html">here</a>.
</div>
<!--br><br-->
</li>

</ol>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<hr style="border-top:3px solid darkblue;">
<script src="../js/script_toggle.js"></script>
<script>includeMyCode();</script>
<script>includeHTML();</script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</body>
</html>
