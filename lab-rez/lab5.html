<!DocType html>
<html lang="ro">
<head>
  <title>Disciplina SO - Laborator #5 (suport online)</title>
  <link rel="stylesheet" type="text/css" href="../my_styles.css" />
    <meta name="description" content="Sisteme de operare - curs și laborator - suport electronic">
    <meta name="keywords"    content="Operating Systems, Sisteme de operare, Unix, Linux, FII Iași, infoiasi, Cristian Vidrașcu">
    <meta name="author"      content="Cristian Vidrașcu">
    <meta charset="utf-8"><!-- pentru diacritice -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<script src="../js/script_include.js"></script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<body>

<h2><font color="blue">Laborator #5 :</font> suport online &nbsp; ( Îndrumar de laborator )</h2>

<b>Sumar:</b>
<h3>I) <a href="#sec_1" class="button_href">Lucrul la linia de comandă în Linux, cu fișiere de comenzi (partea a doua)</a></h3>
<h4>I.1) Recap: <a href="#sec_1a" class="button_href">Reamintirea unor cunoștințe dobândite în lecția practică despre interpretoare de comenzi, partea a II-a</a></h4>
<h4>I.2) Exemplificări: <a href="#sec_1b" class="button_href">Exemple de utilizare a unor fișiere de comenzi (exerciții rezolvate)</a></h4>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; a) <a href="#sec_1b1" class="button_href">Exemple de <i>script</i>-uri ce efectuează diverse procesări de fișiere (și alte resurse)</a></h5>
<h5>&nbsp; &nbsp; &nbsp; &nbsp; b) <a href="#sec_1b2" class="button_href">Exemple de <i>script</i>-uri ce efectuează parcurgeri recursive ale sistemului de fișiere</a></h5>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:5px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1">I) <span class="stil_sumar">Lucrul la linia de comandă în Linux, cu fișiere de comenzi (partea a doua)</span> :</p>

<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1a">I.1) <span class="stil_recap">Reamintirea unor cunoștințe dobândite în lecția practică despre interpretoare de comenzi, partea a II-a</span> :</p>

<b>Informații despre limbajul de <i>scripting</i> bash pentru automatizarea lucrului la linia de comandă în Linux:</b>
<button onclick="myToggle('lab5_recap')">Hide / Show the presentation</button>
<div id="lab5_recap" style="display:block;" class="stil_prezentare">
<p>
(Re)citiți prezentarea cu lecția practică despre interpretoare de comenzi în Linux - partea a II-a, disponibilă
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/lectures/Linux/P4_shell2_web-ro.pdf">aici</a>.
</p>
<p>
<font color="red">Recomandare:</font>
<button onclick="myToggle('lab5_recap_bib')">Show / Hide the recommendation</button>
<div id="lab5_recap_bib" class="stil_bibliografie_suplimentara">
Nu vă rezumați doar la consultarea prezentării PPT indicate  mai sus;
citiți și subcapitolul corespunzător din cartea recomandată pentru componenta practică:
<a target="_blank" href="https://profs.info.uaic.ro/~vidrascu/SO/books/ManualID-SO_chapters/shellprg.pdf">Cap. 2, §2.4</a>.
<!--
<br><br>
<i>Notă</i>: o versiune mai veche a acestui material, în format HTML, este disponibilă spre consultare
<a target="_blank" href="http://students.info.uaic.ro/~so/labs/shellprg.htm">aici</a>.
-->
</div>
</p>
</div>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:3px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b">I.2) <span class="stil_ex_rezolvate">Exemple de utilizare a unor fișiere de comenzi (exerciții rezolvate)</span> :</p>

<p class="stil_observatie_level0">
<b><i>Observație importantă</i></b>:
precum vă spuneam și la lecția din săptămâna precedentă, în exemplele de scripturi prezentate în
<a href="suport_lab4.html#sec_1b">suportul de laborator #4</a> la punctele b), c) și d),
ne-am concentrat atenția pe ilustrarea diferitelor construcții sintactice și comenzi interne ale
limbajului de <i>scripting</i> <tt>bash</tt>,
utilizând pentru aceasta implementarea în acest limbaj a unor algoritmi ușor de înțeles pe baza cunoștințelor dvs. anterioare,
i.e. algoritmi ce efectuează diferite calcule matematice (iterative și recursive).
<br>
Rețineți însă faptul că obiectivul principal al acestui limbaj de <i>scripting</i> nu este acela de a face calcule matematice
(există alte limbaje de programare ce sunt mai adecvate pentru acest scop), ci acela de a permite <b>automatizarea lucrului la
linia de comandă</b> în sistemele de operare din familia Unix, cum ar fi de exemplu pentru execuția a diverse sarcini de
administrare a sistemului, sau pentru manipularea resurselor sistemului (fișiere, procese, ș.a.).
<br>
Ca atare, după ce în lecția anterioară v-ați însușit sintaxa și semantica limbajului de <i>scripting</i> <tt>bash</tt>,
în lecția din această săptămână, i.e. în acest <u>suport de laborator #5</u>, vom ilustra o serie de script-uri care execută
astfel de <b>operații de administrare / manipulare de resurse</b>.
</p>

<ol>

<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b1">a) <span class="stil_ex_rezolvate">Exemple de <i>script</i>-uri ce efectuează diverse procesări de fișiere (și alte resurse)</span> :</p>


<li><!-- Problema: lab5_ex-new0.sh --------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Run SPMD programs]</span>
<br>
Să se scrie un script care, primind la linia de comandă calea către un program executabil (sau un script),
un număr <tt>n</tt> și o secvență de <tt>n</tt> valori,
lansează în execuție paralelă și neînlănțuită <tt>n</tt> instanțe ale acelui program (sau script),
iar fiecare din cele <tt>n</tt> instanțe va fi apelată cu un argument -- cu câte una dintre cele <tt>n</tt> valori primite în linia de comandă.
<br>
<i>Explicație</i>: acronimul <b>SPMD</b> înseamnă <i>Single-Program-Multiple-Data</i> și descrie un șablon de programare paralelă,
în care <tt>n</tt> instanțe ale unui program secvențial sunt executate în paralel, pe date diferite, în manieră asincronă.
Bineînțeles, cel mai adesea cele <tt>n</tt> instanțe cooperează între ele, sub diverse forme de interacțiune.
<br>
<i>Notă</i>: există și varianta sincronă, denumită <b>SIMD</b>, i.e. <i>Single-Instruction-Multiple-Data</i>,
care este un șablon de programare paralelă mult mai restrictiv,
căci presupune execuția sincronizată în paralel a celor <tt>n</tt> instanțe,
i.e. la orice moment toate cele <tt>n</tt> instanțe execută aceeași instrucțiune, pe date diferite!
</p>

<button onclick="myToggle('lab5_ex0')">Show / Hide a possible solution</button>
<div id="lab5_ex0" class="stil_rezolvare">
O posibilă soluție este următoarea:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab5/RunMySPMD.sh">See the script from <a target="_blank" href="demo/lab5/RunMySPMD.sh">here</a>.</div>
</pre>
<p>
Iată și câteva exemple simple de apelare a acestui script:
</p>
<p>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./RunMySPMD.sh /bin/ls 3 ~ /usr/share /proc</code>
</p>
<p>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./RunMySPMD.sh /bin/cat 2 /etc/passwd /etc/group</code>
</p>
<p>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/demo/bash/</font>$</tt>
    <code class="stil_cmdBash"> ./RunMySPMD.sh /bin/ps 3 a -ef -af</code>
<!--
<pre class="stil_cmdBash">./RunMySPMD.sh /bin/ls 3 ~ /usr/share /proc</pre>
<pre class="stil_cmdBash">./RunMySPMD.sh /bin/cat 2 /etc/passwd /etc/group</pre>
<pre class="stil_cmdBash">./RunMySPMD.sh /bin/ps 3 a -ef -af</pre>
-->
</p>
<p>
<i>Explicație detaliată</i>, despre exemplele de apelare de mai sus:
<button onclick="myToggle('lab5_ex0a')">Show / Hide the full details</button>
<div id="lab5_ex0a" style="display:none;width:50%;" class="stil_image_frame"><img width="95%" src="demo/lab5/RunMySPMD_image{BP}.png" align="middle"></div>
</p>
<p>
<i>Observație importantă</i>: puteți utiliza acest script în partea a doua a laboratoarelor,
pentru a rula anumite programe C în conformitate cu șablonul de paralelism <b>SPMD</b>.
</p>
</div>
<br><br>
</li>


<!--li><!-- Problema: lab5_ex9.sh -------------------------------------------------------------------------------------------no>
<p><span class="stil_titlu_ex">[MyGccOrCat]</span>
...
Notă: am mutat-o în prima parte, i.e. suport_lab4.html !
</li-->


<li><!-- Problema: lab4_ex15.sh ------------------------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[MyG++]</span><!-- old lab.3,IV,ex.2 ; old ex.3 -->
<br>Să se scrie un script care primește ca parametru la linia de comandă un director și care compilează toate fișierele sursă C++
aflate doar în acest director. <!--(nu și cele din subdirectoarele lui).-->
(Compilarea se va realiza în felul următor: &nbsp; <code class="stil_cmdBash">g++ fisier.cpp -o fisier -Wall</code> .)
<br>
(<i>Atenție</i>: NU se cere parcurgerea recursivă a directorului respectiv!)
<br>
<small>(Indicație: <span class="stil_hint2">folosind comanda basename se poate obține numele fișierului fără extensie, e.g.
<code class="stil_cmdBash">basename fisier.cpp .cpp</code> afișează pe stdout doar 'fisier'.
Sau, echivalent, puteți folosi substituțiile ce elimină prefixe și sufixe din valaorea unei variabile.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex15')">Show / Hide the solutions</button>
<div id="lab4_ex15" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">MyG++_v1.sh</tt> --
folosim un șablon de forma <tt class="stil_cmdBash">*.cpp</tt> în lista de cuvinte de la
structura de control <code class="stil_cmdBash">for</code>, șablon ce va fi interpretat de <tt>bash</tt> în modul cunoscut:
</p>
<button onclick="myToggle('lab4_ex15_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex15_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyG++_v1.sh">See the script from <a target="_blank" href="demo/lab5/MyG++_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">MyG++_v2.sh</tt> --
folosim comanda <code class="stil_cmdBash">find</code>, cu parcurgerea limitată la un nivel pe adâncime,
pentru a genera lista numelor de fișiere sursă C++ din directorul dat ca parametru:
</p>
<button onclick="myToggle('lab4_ex15_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex15_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyG++_v2.sh">See the script from <a target="_blank" href="demo/lab5/MyG++_v2.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: deși exercițiul nu o cerea, pentru a compila toate fișierele aflate în subarborele determinat de directorul dat ca parametru,
este suficient ca în scriptul de mai sus să eliminăm opțiunea "-maxdepth 1" de la comanda find.
</p>

<p>
<b>iii)</b> A treia soluție: <tt class="stil_demo_filename">MyG++_v3.sh</tt> --
folosim comanda <code class="stil_cmdBash">ls</code>, cu un șablon de forma <tt class="stil_cmdBash">$1/*.cpp</tt>,
pentru a genera lista numelor de fișiere sursă C++ din directorul dat ca parametru:
</p>
<button onclick="myToggle('lab4_ex15_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex15_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyG++_v3.sh">See the script from <a target="_blank" href="demo/lab5/MyG++_v3.sh">here</a>.</div>
</pre>

<br><br>
<i style="color:red;">Observație suplimentară</i>:
<div class="stil_hidden-text_level1_small-padding">Dacă veți testa oricare dintre cele trei scripturi de mai sus,
dându-i ca argument un director în care se găsesc și fișiere care conțin în numele lor caractere spații sau tab-uri,
atunci pentru respectivele fișiere veți obține erori de genul "File not found",
datorită modului de evaluare a enumerării din structura repetitivă
<code class="stil_cmdBash">for <i>variabila</i> in <i>lista-de-cuvinte</i> ; do ... ; done</code>,
ceea ce face imposibilă protejarea spațiilor din numele fișierelor
și subdirectoarelor obținute cu comenzile <code class="stil_cmdBash">ls -A</code> și <code class="stil_cmdBash">find</code>
(sau cu șabloane de genul <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt>).
&nbsp; &nbsp;
Pentru mai multe detalii, precum și o idee de tratare a acestor nume "excepționale" de fișiere,
citiți observația suplimentară de la finalul rezolvării exercițiului <span class="stil_ref_ex">[MyFind #1]</span> de mai jos.
</div>

</div>
<br><br>
</li>



<li><!-- Problema: editcomp.sh ------------------------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[EditCompileRun]</span><!--  Script pentru automatizarea procesului de dezvoltare de programe C -->
<br>
<b>Script pentru automatizarea procesului de dezvoltare de programe C</b>:
să se scrie un script care să vă ajute la scrierea programelor în C, prin care să se automatizeze ciclul de dezvoltare:
modificare sursă --> compilare --> testare (execuție).
<br>
<big>Cerințe:</big>
<br>Scriptul va lansa editorul preferat pentru fișierul cu numele <tt class="stil_demo_filename"><i>program</i>.c</tt> specificat
ca parametru în linia de comandă (sau citit de la tastatură, în caz contrar),
apoi va interoga utilizatorul dacă dorește să lanseze compilatorul și în caz afirmativ o va face
(fișierul executabil va trebui să aibă numele <tt class="stil_demo_filename"><i>program</i></tt> ,
deci același nume cu sursa C din care provine, dar fără sufixul <tt class="stil_demo_filename">.c</tt>).
Apoi, dacă sunt erori de compilare (lucru observabil prin erorile de compilare afișate de compilator),
va relua ciclul de la editare (bineînțeles cu o pauză pentru ca utilizatorul să aibă timp să citească erorile afișate pe ecran).
Iar dacă nu sunt erori la compilare, va interoga utilizatorul dacă dorește să testeze (i.e., să execute) acel program și,
în caz afirmativ, va executa acel fișier executabil rezultat prin compilare.
<br>
În concluzie, la fiecare pas să se facă o interogare a utilizatorului dacă dorește să continue cu următorul pas.
</p>

<button onclick="myToggle('lab5_editcomp')">Show / Hide a possible solution</button>
<div id="lab5_editcomp" class="stil_rezolvare">
O posibilă soluție este următoarea:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab5/EditCompileRun.sh">See the script from <a target="_blank" href="demo/lab5/EditCompileRun.sh">here</a>.</div>
</pre>
</div>

<p class="stil_observatie_level0">
<i style="color:red;">Important</i>: vă recomand să adaptați acest script după dorință, conform stilului propriu de lucru,
și să-l folosiți în partea a doua a laboratoarelor, pentru a vă automatiza activitatea de dezvoltare a programelor C.
</p>
<br>
</li>



<li><!-- Problema: lab4_ex11.sh ------------------------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[MyId]</span><!-- old lab.3,IV,ex.3 -->
<br>Să se scrie un script care, pentru un utilizator specificat prin UID-ul acestuia dat ca parametru în linia de comandă,
să afișeze numele lui real, plus numele de utilizator, precum și denumirile tuturor grupurilor din care face parte.
<br>
<small>(Indicație: <span class="stil_hint2">pentru a obține informațiile cerute, puteți folosi comanda id și/sau să prelucrați
fișierele <tt>/etc/passwd</tt> și <tt>/etc/group</tt>.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex11')">Show / Hide the solutions</button>
<div id="lab4_ex11" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">MyId_v1.sh</tt> --
folosim informațiile din fișierele <tt>/etc/passwd</tt> și <tt>/etc/group</tt>:
</p>
<button onclick="myToggle('lab4_ex11_1')">Show / Hide the 1st version of this script</button>

<pre id="lab4_ex11_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyId_v1.sh">See the script from <a target="_blank" href="demo/lab5/MyId_v1.sh">here</a>.</div>
</pre>
<p>
<i>Notă</i>: observați faptul că valorile numerice nnn pentru UID și GID le căutăm cu șabloane de forma <tt class="stil_cmdBash">:nnn:</tt>,
deoarece altfel, dacă am folosi ca șablon doar <tt class="stil_cmdBash">nnn</tt>,
comanda <code class="stil_cmdBash">grep</code> ar putea selecta și alte linii de text,
și anume cele în care nnn apare ca subcuvânt într-o secvență mai amplă de cifre.
Iar numele de cont îl căutăm cu <code class="stil_cmdBash">grep -w</code> din același motiv
(fără opțiunea -w, comanda grep ar putea selecta și alte linii de text,
și anume acelea în care numele de cont apare ca subcuvânt într-un cuvânt mai lung).
</p>


<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">MyId_v2.sh</tt> --
este o rescriere echivalentă a primei soluții, fără a mai folosi variabile pentru stocarea rezultatelor intermediare:
</p>
<button onclick="myToggle('lab4_ex11_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex11_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyId_v2.sh">See the script from <a target="_blank" href="demo/lab5/MyId_v2.sh">here</a>.</div>
</pre>

<p>
<i style="color:red;">Atenție</i>: precum vă spuneam anterior,
în trecutul recent (i.e., as of February 2022), serverul <tt>students</tt>  a fost "reconstruit" pe baza altei
distribuții de Linux, CentOS 7, și s-a trecut la gestiunea centralizată a conturilor de utilizatori și a grupurilor de utilizatori de pe server, folosind o tehnologie centralizată de tip LDAP.
Iar ca urmare, în baza de date locală <tt>/etc/passwd</tt> + <tt>/etc/group</tt> nu mai regăsim informații despre conturile tuturor studenților ce pot accesa serverul <tt>students</tt> (a se revedea observația de <a target="_blank" href="suport_lab3.html#sec_1b">aici</a>).
<br>
Din acest motiv, în prezent, dacă veți dori să testați nu doar local, ci și pe serverul <tt>students</tt>, primele două versiuni ale acestui script, nu veți putea obține pe server rezultatele așteptate (decât niște rezultate parțiale, dacă veți folosi fișierul <tt style="color: blue;">etc-passwd_sanitized.txt</tt>, ce conține un fragment din conținutul din 2021 al bazei de date locale <tt>/etc/passwd</tt> de pe server, cu informațiile personale identificabile modificate, pe care vi l-am pus la dispoziție în suportul de laborator #3).
</p>

<p>
<b>iii)</b> A treia soluție: <tt class="stil_demo_filename">MyId_v3.sh</tt> --
este o altă rescriere echivalentă a primei soluții, dar de data aceasta
folosim comanda <code class="stil_cmdBash">id</code> în locul fișierului <tt>/etc/group</tt>:
</p>
<button onclick="myToggle('lab4_ex11_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex11_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyId_v3.sh">See the script from <a target="_blank" href="demo/lab5/MyId_v3.sh">here</a>.</div>
</pre>

<p>
<i style="color:red;">Atenție</i>: în prezent, dacă veți dori să testați nu doar local, ci și pe serverul <tt>students</tt>,
a treia versiune a acestui script,
va trebui să folosiți informațiile din fișierul <tt style="color: blue;">etc-passwd_sanitized.txt</tt>
în loc de <tt>/etc/passwd</tt>, din același motiv explicat mai sus.
</p>

<p>
<b>iv)</b> A patra idee: putem folosi doar comanda <code class="stil_cmdBash">id</code>,
fără a procesa informațiile din fișierele <tt>/etc/passwd</tt> și <tt>/etc/group</tt>,
pentru a obține informațiile cerute în enunțul acestui exercițiu,
inclusiv pe serverul <tt>students</tt> în configurația sa actuală (i.e., <i>as of March 2024</i>).
<br>
Pentru aceasta, pornim de la observația, dedusă pe cale experimentală, că putem apela comanda <code class="stil_cmdBash">id</code>
cu un argument care reprezintă UID-ul unui utilizator, în loc de un <i>username</i>.
Spre exemplu, dacă introducem comanda următoare:
<br>
<tt><font color="#4E9A06">vidrascu@profs</font>:<font color="#3465A4">~/SO/</font>$</tt>
    <code class="stil_cmdBash"> id 489800064</code>
<br>
vom obține următorul output afișat pe ecran prin execuția acestei comenzi:
<pre class="stil_output">
uid=489800064(vidrascu) gid=489800064(vidrascu) groups=489800064(vidrascu),489800003(profesori)
</pre>
Nu ne mai rămâne altceva de făcut decât să prelucrăm cele trei cuvinte (separate prin spații) din acest output,
reprezentând utilizatorul, grupul principal și respectiv toate grupurile din care face parte,
pentru a extrage informațiile dorite și a le afișa într-un format similar cu cel din soluțiile anterioare. 
<br><br>
<i>TODO</i>:
vă rămâne ca exercițiu să scrieți dvs. un script în care să implementați ideea descrisă mai sus, i.e. de prelucrare
a output-ului comenzii <code class="stil_cmdBash">id</code> apelate cu un argument ce reprezintă UID-ul unui utilizator.
</p>

</div>
<br><br>
</li>



<li><!-- Problema: lab4_ex12.sh ------------------------------------------------------------------------------------------>
<p><span class="stil_titlu_ex">[WhoHasWebpage?]</span>
<br>Să se scrie un script care să afișeze care dintre utilizatorii ce sunt studenți și al căror nume de cont începe cu o literă dată,
au pagini web pe vechiul server <tt>students</tt>.
<br>
<small>(Indicație: <span class="stil_hint2">se va testa existența și vizibilitatea pentru toată lumea a unuia dintre
fișierele index.htm sau index.html sau index.php, ce ar trebui să se afle în subdirectorul html
din directorul home al utilizatorului ce are pagină web.</span>)</small>
</p>

<button onclick="myToggle('lab4_ex12')">Show / Hide the solutions</button>
<div id="lab4_ex12" class="stil_rezolvare">
<p>
<b>i)</b> O primă idee de rezolvare: <tt class="stil_demo_filename">WhoHasWebpage_v1.sh</tt> --
generăm lista numelor de conturi student (Cum? A se revedea un exercițiu din laboratorul precedent) și o filtrăm după prima literă,
apoi ne "uităm" (i.e. testăm) dacă avem drept de citire în directorul html al fiecăruia pentru
cel puțin unul dintre fișierele specificate:
</p>
<button onclick="myToggle('lab4_ex12_1')">Show / Hide the 1st version of this script</button>
<pre id="lab4_ex12_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/WhoHasWebpage_v1.sh">See the script from <a target="_blank" href="demo/lab5/WhoHasWebpage_v1.sh">here</a>.</div>
</pre>
<p>
<i>Observație importantă</i>: această soluție va afișa un număr redus de studenți cu pagină web,
deși majoritatea studenților aveau pagină web creată în primul semestru (cel puțin, cei din promoțiile mai vechi).
<br>
Explicația constă în faptul că acest script verifică dacă studentul X (cel care rulează scriptul) are acces la acele fișiere index ale
fiecărui student Y și afișează numele lui Y în caz afirmativ.
Numai că X și Y sunt colegi în grupul studs, iar a avea pagină web înseamnă a avea unul din acele fișiere index accesibil
pentru serverul HTTP Apache, care este un program ce rulează ca root,
deci intră în categoria others pentru drepturile specificate de Y pe fișierele sale index.
Cu alte cuvinte, orice student Y care și-a setat drepturi de forma 604 pe fișierul <tt>index.{html,htm,php}</tt>,
va avea acel fișier accesibil serverului HTTP Apache, dar nu și colegilor de grup. 
</p>

<p>
<b>ii)</b> A doua idee de rezolvare: <tt class="stil_demo_filename">WhoHasWebpage_v2.sh</tt> --
încercăm să testăm cu <code class="stil_cmdBash">find ... -perm ...</code> dacă vreunul dintre acele fișiere index are
permisiune de citire pentru others (și prin urmare va fi accesibil serverului HTTP Apache),
indiferent dacă colegii de grup au sau nu drept de citire:
</p>
<button onclick="myToggle('lab4_ex12_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab4_ex12_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/WhoHasWebpage_v2.sh">See the script from <a target="_blank" href="demo/lab5/WhoHasWebpage_v2.sh">here</a>.</div>
</pre>
<p>
<i>Observație importantă</i>: deci nici această soluție nu ne oferă lista completă a studenților care au pagină web,
și anume: pentru acei studenți Y care și-au setat drepturi de forma 701 pe directorul home și/sau pe subdirectorul html,
orice comandă (e.g. <code class="stil_cmdBash">test ...</code>, <code class="stil_cmdBash">find ...</code>,
<code class="stil_cmdBash">stat ...</code>, ș.a.) ar încerca să folosească studentul X,
comanda nu va putea accesa fișierul index al studentului Y pentru a-i putea testa drepturile de acces sau existența.
</p>
<p>
<b>Concluzie</b>: drepturile de acces la fișiere reprezintă un mecanism important de protecție,
ce garantează "filtrarea" acceselor (i.e. permiterea doar a unora dintre ele și interzicerea altora)
la un fișier în conformitate cu dorințele proprietarului.
</p>
<p>În cazul de față, pentru a putea totuși "vedea" existența paginilor "ascunse" ale acelor studenți care au interzis accesul
pentru colegii de grup, dar l-au lăsat permis pentru categoria others,
cu scopul de a fi accesibil serverului HTTP Apache, soluția este următoarea:
</p>

<p>
<b>iii)</b> A treia soluție, cea corectă: <tt class="stil_demo_filename">WhoHasWebpage_v3.sh</tt> --
studentul X încearcă să acceseze paginile studentului Y nu prin diverse comenzi rulate avându-l drept proprietar al procesului pe X,
ci printr-o comandă care rulează în numele unui cont de sistem, de exemplu, deci care nu se încadrează în colegii de grup ai lui Y.
</p>
<p>
O posibilă astfel de comandă este invocarea tocmai a serverului HTTP Apache, ce rulează ca root.
Invocarea se poate face printr-un browser în mod text, care va rula în numele lui X, și-i va cere serverului HTTP Apache să-i livreze
continuțul paginii de la adresa http specificată în browser.
Fișierul propriu-zis al acelei pagini va fi accesat în sistemul de fișiere nu de către procesul browser rulat de studentul X,
ci de către procesul server HTTP Apache, și astfel putem "vedea" paginile web dacă există (și aceasta, în mod evident,
fără a încălca drepturile de acces specificate de proprietarii paginilor web, pentru situațiile amintite mai sus).
</p>
<button onclick="myToggle('lab4_ex12_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab4_ex12_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/WhoHasWebpage_v3.sh">See the script from <a target="_blank" href="demo/lab5/WhoHasWebpage_v3.sh">here</a>.</div>
</pre>
</div>
<p class="stil_observatie_level0">
<i style="color:red;">Observație importantă</i>: în prezent, dacă doriți să testați pe noul (i.e., <i>as of February 2024</i>)
server <tt>students-a</tt> cele trei variante de script prezentate mai sus, acestea nu vor funcționa în maniera dorită,
deoarece NU pot fi folosite informațiile din fișierul <tt>/etc/passwd</tt> datorită motivului explicat anterior
(a se revedea observația de <a target="_blank" href="suport_lab3.html#sec_1b">aici</a>).
Și nici fișierul <tt style="color: blue;">etc-passwd_sanitized.txt</tt> (ce conține un fragment din conținutul din 2021 al bazei de date locale <tt>/etc/passwd</tt> de pe server, cu informațiile personale identificabile modificate, pe care vi l-am pus la dispoziție în suportul de laborator #3) nu poate fi folosit, deoarece pe noul server nu mai există acele conturi.
<br>
Singura soluție alternativă este aceea de a modifica variantele de script prezentate, în sensul de a extrage lista de username-uri actuale de pe server (ignorând cerința de a fi studenți și nu alte roluri)
prin prelucrarea listingului directorului <tt>/home</tt> de pe noul server și, în plus,
mai trebuie adaptat într-un mod adecvat codul din script ce procesează acele username-uri.
<br><br>
<i>TODO</i>:
vă rămâne ca exercițiu să faceți dvs. modificările necesare în script prin care să implementați ideea descrisă mai sus.
</p>
<br><br>
</li>


<!------------------------------------------------------------------------------------------------------------------------>
<hr style="border-top:2px solid darkblue;">
<!------------------------------------------------------------------------------------------------------------------------>
<p id="sec_1b2">b) <span class="stil_ex_rezolvate">Exemple de <i>script</i>-uri ce efectuează parcurgeri recursive ale sistemului de fișiere</span> :</p>


<li><!-- Problema: lab5_ex7.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Call2Find #1]</span><!-- exercițiu cu apel de find -->
<br>Să se scrie un script care să afișeze toate comentariile din scripturile aflate într-un director specificat ca argument sau în subdirectoarele acestuia.
<br>
<i>Ipoteză simplificatoare</i>: pentru a putea deosebi fișierele ce sunt scripturi <tt>bash</tt> de alte genuri de
fișiere text, vom face presupunerea că scripturile <tt>bash</tt> au nume cu extensia <tt>.sh</tt>,
deși această ipoteză nu este întotdeauna adevărată !!!
<br>
(Soluția corectă, în acest caz, este puțin mai elaborată: putem procesa output-ul comenzii <code>file</code> pentru a testa
dacă conținutul unui fișier, indiferent de extensia din numele acestuia, reprezintă sau nu un script <tt>bash</tt>.)
<br>
<i style="color:red;">Atenție</i>: NU se cere ca parcurgerea recursivă a directorului respectiv să fie explicită,
i.e. puteți folosi comanda <code>find</code> sau comanda <code>ls -R</code> pentru a parcurge directorul specificat.
</p>

<button onclick="myToggle('lab5_ex7')">Show / Hide a possible solution</button>
<div id="lab5_ex7" class="stil_rezolvare">
Iată o posibilă rezolvare:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab5/Call2Find_1.sh">See the script from <a target="_blank" href="demo/lab5/Call2Find_1.sh">here</a>.</div>
</pre>
<p>
<i>Observația #1</i>: prima comandă <code class="stil_cmdBash">grep</code> are rolul de a selecta liniile ce conțin comentarii,
iar opțiunea <tt class="stil_cmdBash">-n</tt> este pentru a le prefixa cu numărul lor de ordine în fișier.
Iar ultimele două comenzi <code class="stil_cmdBash">grep</code> au rolul de a elimina liniile în care apare variabila specială
<tt class="stil_cmdBash">$#</tt>, respectiv de a elimina linia de forma <tt class="stil_cmdBash">#!shellul_dorit</tt>
(aflată de obicei pe prima linie dintr-un script).
Evident, astfel se vor pierde la afișare eventualele comentarii scrise pe aceeași linie în care apare <tt class="stil_cmdBash">$#</tt>
sau <tt class="stil_cmdBash">#!shell</tt>.
</p>
<p>
<i>Observația #2</i>: observați criteriul de selecție <tt class="stil_cmdBash">-type f</tt> adăugat la comanda <code class="stil_cmdBash">find</code>,
împreună cu criteriul <tt class="stil_cmdBash">-name "*.sh"</tt>.
Astfel ne asigurăm că vom selecta doar fișiere de tipul obișnuit (deci nu și directoare, sau celelalte patru tipuri de fișiere)
al căror nume se termină cu extensia <tt>.sh</tt>, pentru a selecta doar scripturi, conform cerinței din enunț.
<br>
De fapt însă, această condiție nu ne garantează că va selecta DOAR scripturile, căci nu este suficient să ne uităm la numele fișierului
(și la tipul lui), ci trebuie să ne uităm la conținutul lui, pentru a fi siguri că este un script.
<br>
Iar aceasta o putem face, de exemplu, cu comanda:
<code class="stil_cmdBash">file</code>, care va inspecta prima linie și, dacă este de forma <tt class="stil_cmdBash">#!shell</tt>,
atunci va afișa un text de genul: "<tt><i>nume_fisier</i>: Bourne-Again shell script, ...</tt>" (în cazul liniei
<tt class="stil_cmdBash">#!/bin/bash</tt>) sau alt mesaj similar (în funcție de <i>shell</i>-ul specificat pe prima linie).
Vă las ca temă pentru acasă să rescrieți dvs. scriptul de mai sus folosind această idee bazată pe outputul comenzii <code class="stil_cmdBash">file</code>.
</p>

<br>
<i style="color:red;">Observație suplimentară</i>:
<div class="stil_hidden-text_level1_small-padding">Dacă veți testa scriptul de mai sus, dându-i ca argument un director în
care se găsesc și fișiere (sau subdirectoare) care conțin în numele lor caractere ce sunt spații sau tab-uri,
atunci pentru respectivele fișiere veți obține erori de genul "File not found",
datorită modului de evaluare a enumerării din structura repetitivă
<code class="stil_cmdBash">for <i>variabila</i> in <i>lista-de-cuvinte</i> ; do ... ; done</code>,
ceea ce face imposibilă protejarea spațiilor din numele fișierelor și subdirectoarelor obținute cu
comanda <code class="stil_cmdBash">ls -A</code>
(sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
&nbsp; &nbsp;
Pentru mai multe detalii despre acest subiect, precum și o idee de tratare a acestor nume "excepționale" de fișiere,
citiți observația suplimentară de la finalul rezolvării exercițiului <span class="stil_ref_ex">[MyFind #1]</span> de mai jos.
</div>

</div>
<br><br>
</li>



<li><!-- Problema: lab5_ex8.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[Call2Find #2]</span><!-- exercițiu cu apel de find -->
<br>Să se scrie un script care primește ca parametri d (un nume de director) și k (un număr întreg pozitiv).
Pentru fiecare fișier pentru care utilizatorul curent are drepturi de citire și execuție,
aflat în directorul dat ca parametru sau în subdirectoarele acestuia, se vor afișa primele k linii de text.
<br>
<i style="color:red;">Atenție</i>: NU se cere ca parcurgerea recursivă a directorului respectiv să fie explicită,
i.e. puteți folosi comanda <code>find</code> sau comanda <code>ls -R</code> pentru a parcurge directorul specificat.
</p>

<button onclick="myToggle('lab5_ex8')">Show / Hide the solutions</button>
<div id="lab5_ex8" class="stil_rezolvare">
<p>
<b>i)</b> Prima soluție: <tt class="stil_demo_filename">Call2Find_2_v1.sh</tt> -- iată o posibilă idee de rezolvare:
</p>
<button onclick="myToggle('lab5_ex8_1')">Show / Hide the 1st version of this script</button>
<pre id="lab5_ex8_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/Call2Find_2_v1.sh">See the script from <a target="_blank" href="demo/lab5/Call2Find_2_v1.sh">here</a>.</div>
</pre>

<p>
<b>ii)</b> A doua soluție: <tt class="stil_demo_filename">Call2Find_2_v2.sh</tt> -- este o rescriere echivalentă a primei soluții,
în care testele din <code class="stil_cmdBash">if</code> le "mutăm" la <code class="stil_cmdBash">find</code>:
</p>
<button onclick="myToggle('lab5_ex8_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab5_ex8_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/Call2Find_2_v2.sh">See the script from <a target="_blank" href="demo/lab5/Call2Find_2_v2.sh">here</a>.</div>
</pre>
<br>
<br>
<p class="stil_QandA"><i>Întrebare</i>:
chiar dacă ambele soluții de mai sus sunt corecte, i.e. "calculează" ceea ce se cere în problema noastră,
care dintre ele credeți că este mai performantă (d.p.d.v. al timpului de execuție și/sau consumului de resurse ale sistemului pentru execuția sa) ?
<br><i>Răspuns</i>: a doua soluție, deoarece numărul de iterații executate în bucla <code class="stil_cmdBash">for</code>
poate fi mai mic decât la prima soluție, <u>de obicei</u>.
<br>Mai precis, în ce situații este mai mic? Încercați să răspundeți singuri la această ultimă întrebare.
</p>

<br>
<i style="color:red;">Observație suplimentară</i>:
<div class="stil_hidden-text_level1_small-padding">Dacă veți testa scriptul de mai sus, dându-i ca argument un director în
care se găsesc și fișiere (sau subdirectoare) care conțin în numele lor caractere ce sunt spații sau tab-uri,
atunci pentru respectivele fișiere veți obține erori de genul "File not found",
datorită modului de evaluare a enumerării din structura repetitivă
<code class="stil_cmdBash">for <i>variabila</i> in <i>lista-de-cuvinte</i> ; do ... ; done</code>,
ceea ce face imposibilă protejarea spațiilor din numele fișierelor și subdirectoarelor obținute cu
comanda <code class="stil_cmdBash">ls -A</code>
(sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
&nbsp; &nbsp;
Pentru mai multe detalii despre acest subiect, precum și o idee de tratare a acestor nume "excepționale" de fișiere,
citiți observația suplimentară de la finalul rezolvării exercițiului <span class="stil_ref_ex">[MyFind #1]</span> de mai jos.
</div>

</div>
<br><br>
</li>



<li><!-- Problema: lab5_ex4.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyFind #1]</span>
<br>Să se scrie un script care calculează și afișează numărul total de fișiere de tip fifo și numărul total de subdirectoare
aflate într-un director dat, <u>parcurgand directorul recursiv, în mod explicit</u>
(i.e. fără a apela comanda <code>find</code> sau comanda <code>ls -R</code>).
Numele directorului de pornire se transmite ca parametru în linia de comandă, sau se va citi prin comanda read în caz contrar.
<br>
<small>(Indicație: <span class="stil_hint2">parcurgeți cu un for directorul curent și calculați informațiile solicitate, iar
pentru fiecare intrare din director care este de tipul (sub)director apelați recursiv scriptul.</span>)</small>
<br>
<i>Cerință suplimentară</i>: să se afișeze acele informații totale pentru fiecare subdirector parcurs.
</p>

<button onclick="myToggle('lab5_ex4')">Show / Hide the solutions</button>

<div id="lab5_ex4" class="stil_rezolvare">
<p>
Ideea de rezolvare -- similar ca la exercițiile cu calcule aritmetice recursive din laboratorul precedent, avem următoarele posibilități de implementare:
<ul>
<li><b>Recursia</b> se poate implementa în două maniere diferite, exemplificate în soluțiile ce urmează a fi prezentate mai jos:
<br>a) fie prin <i>apel recursiv de funcție</i> (a se vedea prima soluție de mai jos),
<br>b) fie prin <i>apel recursiv de procedură/script</i> (a se vedea celelalte trei soluții de mai jos),
iar în acest caz trebuie să ținem cont și de modul de apel,
i.e. dacă vor fi executate toate apelurile de aceeași instanță de shell,
caz în care avem "memorie comună" între apeluri (a se vedea soluțiile a treia și a patra de mai jos),
sau fiecare apel va fi executat de o nouă instanță a shell-ului,
caz în care NU mai avem variabile partajate între apeluri (a se vedea a doua soluție de mai jos).
<br><br>
</li>
<li><b>Valorile intermediare</b> ale statisticilor ce se cer a fi calculate în manieră recursivă,
se pot transmite de la un apel la altul prin mai multe modalități, i.e. prin cele patru metode ilustrate la calculul
factorialului în exercițiul <span class="stil_ref_ex">[Recursive math #1]</span> din suportul de laborator precedent:
<br>i) fie prin codul de terminare a procesului,
<br>ii) fie prin "preluarea", în linia de comandă a apelantului, a valorii afișate pe ecran de apelat,
<br>iii) fie printr-o variabilă globală,
<br>iv) fie printr-un al doilea parametru de apel al funcției/scriptului.
<br>  
<i>Notă</i>: varianta i) este foarte limitată, căci permite transmiterea unei singure valori, iar aceasta este restricționată la un octet fără semn.
Celelalte variante pot fi folosite și atunci când avem de transmis mai multe valori de la un apel la altul, cum este cazul exercițiului acesta!
</li>
</ul>
</p>

<p>
<i style="color:red;">Observație</i>:
noutatea introdusă de acest exercițiu, față de calculele aritmetice recursive din laboratorul precedent, este dată de faptul că
acum avem de prelucrat nu o secvență de numere, ci o structură arborescentă de directoare din sistemul de fișiere:
<ul>
<li>Prin recursie coborâm în adâncime în arborele de fișiere, iar deplasarea pe orizontală, i.e. parcurgerea intrărilor dintr-un director, o facem cu o structură repetitivă de tipul for:
<br><code class="stil_cmdBash">for f in &lt;lista-de-intrari-din-director&gt; ;do ... ;done</code>
<br>Iar lista de intrări din directorul ce reprezintă argumentul de la apelul curent, poate fi generată în două maniere:
<br>a) fie cu ajutorul comenzii <code>ls</code>:  <code class="stil_cmdBash">$(ls -A <i>director</i>)</code>
<br>b) fie cu șabloane de specificare a fișierelor:
<tt class="stil_cmdBash"><i>director</i>/*</tt> și <tt class="stil_cmdBash"><i>director</i>/.*</tt>
</li>
<li>Un alt aspect pe care trebuie să-l luăm în seamă, este cum gestionăm specificarea căii până la fișierul curent, în arborele de fișiere parcurs prin recursie?
Iarăși avem două variante posibile de implementare:
<br>a) fie specificăm explicit calea către intrarea curentă de prelucrat, i.e. <tt class="stil_cmdBash">$director/$f</tt> (a se vedea primele trei soluții de mai jos);
<br>b) fie schimbăm directorul curent de lucru la fiecare apel recursiv, astfel încât să putem specifica simplu intrarea curentă doar prin <code class="stil_cmdBash">$f</code> (a se vedea soluția a patra de mai jos).
</li>
</ul>
</p>


<p>
<b>1)</b> Prima soluție: <tt class="stil_demo_filename">MyFind_1_v1.sh</tt> --
folosim o funcție recursivă pentru a parcurge subarborele de fișiere cu rădăcina în directorul dat:
</p>
<button onclick="myToggle('lab5_ex4_1')">Show / Hide the 1st version of this script</button>
<pre id="lab5_ex4_1" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_1_v1.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_1_v1.sh">here</a>.</div>
</pre>

<p>
<b>2)</b> A doua soluție: <tt class="stil_demo_filename">MyFind_1_v2.sh</tt> --
în loc de funcție recursivă, folosim apelul recursiv al scriptului:
</p>
<button onclick="myToggle('lab5_ex4_2')">Show / Hide the 2nd version of this script</button>
<pre id="lab5_ex4_2" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_1_v2.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_1_v2.sh">here</a>.</div>
</pre>
<p>
<i>Observația #1</i>: observați forma de apel a scriptului -- este prima dintre formele de apel a unei comenzi simple,
prin care se creează un nou proces shell (i.e. o nouă instanță a interpretorului bash) ce va executa o nouă instanță a scriptului.
<br>Ca atare, întrucât variabilele <tt>nr_dir</tt> și <tt>nr_fif</tt> sunt locale fiecărui proces shell în parte,
nu mai putem doar să le incrementăm ca la soluția anterioară cu o funcție apelată recursiv (unde toate apelurile
sunt executate în cadrul unui singur proces shell, nu se creează câte un nou proces pentru fiecare apel de funcție).
<br>Din acest motiv, pentru a putea transmite totalurile intermediare din apelurile recursive ale scriptului,
putem folosi scrierea lor pe ecran și preluarea în procesul apelant cu substituția specială comandă.
(<i>Notă</i>: nu merge nici să folosim codul de terminare în acest scop, deoarece sunt două valori ce trebuie transmise
procesului apelant, plus că avem și limitarea de un singur octet fără semn pentru reprezentarea codului de terminare.)
</p>
<p>
<i>Observația #2</i>: observați folosirea caracterului '<tt>M</tt>' ca prefix în ambii termeni din ultimul test;
el este doar un artificiu ajutător, pentru ca test-ul să nu dea eroare de sintaxă în situațiile în care <tt>$2</tt> este șirul vid
(ceea ce se întâmplă la apelul inițial al scriptului).
Doar apelurile recursive vor primi un al doilea parametru, marcatorul '<tt>apel_recursiv</tt>',
pentru a putea afișa rezultatele în format diferit la apelurile recursive față de apelul inițial.
</p>

<p>
<i>Observația #3</i>: această soluție are un dezavantaj -- fiecare apel recursiv produce un nou proces shell și, ca urmare,
dacă apelați scriptul având ca argument un director pentru care subarborele de fișiere cu rădăcina în el are o adâncime de aprox.
25 de nivele, vă veți atinge limita maximă de procese simultane per utilizator fixată pe serverul <tt>students</tt>.
</p>
<p>
La soluțiile următoare vom vedea cum putem înlătura acest dezavantaj:
vom folosi pentru apelul recursiv a treia formă de apel a unei comenzi simple, valabilă numai pentru scripturi (și anume,
forma cu cuvintele cheie <code>.</code> sau <code>source</code>,
i.e. <code class="stil_cmdBash">source script [parametri]</code> ),
prin care NU se creează un nou proces shell (i.e. o nouă instanță a interpretorului <tt>bash</tt>) pentru a rula
noua instanță a scriptului, ci tot procesul shell curent o va executa.
<br>
În acest fel, pe lângă posibilitatea de transmitere a rezultatelor intermediare prin scrierea lor pe ecran și recuperarea lor
în apelant cu substituția specială comandă (precum am procedat la această soluție), avem o nouă posibilitate:
folosirea unor variabile la fel ca la prima soluție, cea cu funcția recursivă, căci de data aceasta
vom avea un singur proces shell pe toată durata de execuție a tuturor apelurilor scriptului.
</p>

<p>
<b>3)</b> A treia soluție: <tt class="stil_demo_filename">MyFind_1_v3.sh</tt> --
folosim apelul recursiv al scriptului cu forma de apelare <code>source</code> și variabile în care contorizăm totalurile:
</p>
<button onclick="myToggle('lab5_ex4_3')">Show / Hide the 3rd version of this script</button>
<pre id="lab5_ex4_3" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_1_v3.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_1_v3.sh">here</a>.</div>
</pre>
<p>
<i>Observația #1</i>: pentru a diferenția apelul inițial de apelurile recursive ale scriptului,
am adăugat un marcator '<tt>apel_recursiv</tt>' drept al doilea parametru doar la apelurile recursive.
Este necesar să facem o astfel de diferențiere nu doar pentru a afișa rezultatele totale doar în apelul inițial (și nu și în cele recursive),
dar și pentru a inițializa cu zero o singură dată, la început, cele două variabile în care contorizăm numărul
de subdirectoare și de fișiere (similar ca la prima soluție, cea cu funcție recursivă).
</p>
<p>
<i>Observația #2</i>: la fel ca la soluția anterioară, și aici am folosit un caracter suplimentar, '<tt>M</tt>',
ca prefix în ambii termeni din comanda test ce compară <tt>$2</tt> cu string-ul "apel_recursiv";
el este doar un artificiu ajutător, pentru ca test-ul să nu dea eroare de sintaxă în situațiile în care <tt>$2</tt> este șirul vid
(ceea ce se întâmplă la apelul inițial al scriptului).
Doar apelurile recursive vor primi un al doilea parametru, marcatorul '<tt>apel_recursiv</tt>',
pentru a putea diferenția apelurile recursive de apelul inițial, precum spuneam în observația anterioară.
</p>

<p>
<b>4)</b> A patra soluție: <tt class="stil_demo_filename">MyFind_1_v4.sh</tt> -- 
este foarte asemănătoare cu cea de-a treia soluție,
i.e. folosim apelul recursiv al scriptului cu forma de apelare <code>source</code> și variabile în care contorizăm totalurile,
precum și un (alt) marcator pentru a diferenția apelul inițial de apelurile recursive ale scriptului,
lucru necesar din aceleași motive explicate la soluția a treia.
</p>
<p>
Diferența față de soluția a treia constă în faptul că vom elimina necesitatea de a gestiona argumentul cale curentă (i.e.,
variabila <i>cale</i> de mai sus), prin renunțarea pur și simplu la acest parametru transmis scriptului.
În locul lui vom folosi o altă idee:
schimbarea directorului curent de lucru înaintea apelului recursiv și refacerea sa după revenirea din apelul recursiv.
</p>
<button onclick="myToggle('lab5_ex4_4')">Show / Hide the 4th version of this script</button>
<pre id="lab5_ex4_4" class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_1_v4.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_1_v4.sh">here</a>.</div>
</pre>
<p>
<i>Observația #1</i>: de data aceasta am folosit marcatorul '<tt>apel recursiv</tt>' în loc de '<tt>apel_recursiv</tt>' pentru a avea
două cuvinte, folosite astfel:
primul cuvânt ('apel') va fi primul argument pentru apelurile recursive (căci nu mai avem o cale dată ca argument în aceste cazuri),
iar al doilea cuvânt ('recursiv') pentru a avea două argumente la apelurile recursive.
Evident, se poate folosi și doar un singur cuvânt ca marcator (i.e. '<tt>apel_recursiv</tt>'), dar atunci trebuie modificate în mod 
adecvat <code>case</code>-ul și cele două <code>if</code>-uri folosite pentru a diferenția apelul inițial de apelurile recursive ale scriptului.
</p>
<p>
<i>Observația #2</i>: la fel ca la soluțiile precedente, și aici am folosit câte un caracter suplimentar, '<tt>M</tt>',
ca prefix și, respectiv, sufix, în ambii termeni din testul ce compară <tt>$1</tt> cu string-ul "apel"
și, respectiv, în ambii termeni din testul ce compară <tt>$2</tt> cu string-ul "recursiv";
motivația fiind similară -- este doar un artificiu ajutător, pentru ca test-ul să nu dea eroare de sintaxă în situațiile
în care <tt>$1</tt> și, respectiv, <tt>$2</tt> este șirul vid (ceea ce se întâmplă la apelul inițial al scriptului).
</p>

<br>
<i style="color:red;">Observație suplimentară</i>, comună pentru toate soluțiile de mai sus:
<button onclick="myToggle('lab5_ex4_final')">Show / Hide some final remarks about these solutions</button>
<div id="lab5_ex4_final" class="stil_hidden-text_level1">
<p class="stil_observatie_level0">
<i style="color:red;">Important</i>: în rezultatele obținute de soluțiile date la acest exercițiu,
NU vor fi luate în calcul fișierele fifo și subdirectoarele care conțin în numele lor caractere ce sunt spații sau tab-uri,
ci acestea vor genera erori de genul "File not found",
datorită modului de evaluare a enumerării din structura repetitivă
<code class="stil_cmdBash">for <i>variabila</i> in <i>lista-de-cuvinte</i> ; do ... ; done</code>,
ceea ce face imposibilă protejarea spațiilor din numele fișierelor și subdirectoarelor obținute
cu comanda <code class="stil_cmdBash">ls -A</code> (sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
<br><br>
Repararea acestui neajuns s-are putea face, de exemplu, folosind o singură comandă <code class="stil_cmdBash">find</code>,
care implicit va parcurge recursiv directorul dat,
iar cu opțiunea <tt class="stil_cmdBash">-exec <i>cmd</i></tt> de la <code class="stil_cmdBash">find</code>
i se poate da o comandă <tt><i>cmd</i></tt> adecvată care să facă actualizarea variabilelor de contorizare.
<br>
Însă această soluție, cu <code class="stil_cmdBash">find</code>, nu se încadrează în scopul acestui exercițiu,
acela de a implementa dvs. <b>explicit</b> recursia, fie printr-un script, fie printr-o funcție,
care să parcurgă recursiv prin apeluri explicite (!) directorul dat.
Ca atare, ignorăm neajunsul amintit pe care-l au soluțiile propuse mai sus.
</p>
<div class="stil_hidden-text_level2">
<b>Topici avansate</b> (<i>pentru studenții mai buni, pasionați de tehnologie, ce doresc să afle informații și despre alte subiecte suplimentare, în plus față de setul minimal de cunoștințe predat în cadrul disciplinei SO</i>) :
<br><br>
Totuși, dacă doriți să tratați neapărat și această situație, a fișierelor ce conțin spații în nume, există și o altă soluție,
deși nu e foarte elegantă, de a "proteja" totuși, pentru comanda <code class="stil_cmdBash">for</code>, spațiile din numele fișierelor și subdirectoarelor
obținute cu comanda <code class="stil_cmdBash">ls -A</code> (sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
Ideea este următoarea:
<pre class="stil_codBash">
for fis in $(ls -1A | tr " " / )
do
  original_name=$(echo $fis | tr / " " )
  echo Prelucrează fișierul cu numele $original_name ...
done
</pre>
<i>Explicație</i>: înlocuim spațiile cu un caracter invalid (i.e. ce nu poate apare în numele de fișiere) ca să generăm lista de cuvinte pentru bucla <code class="stil_cmdBash">for</code>,
iar apoi înlocuim la loc acel caracter "/" cu spațiu pentru a obține numele fișierului de prelucrat în iterația curentă din bucla <code class="stil_cmdBash">for</code>.
<br>
Într-o manieră similară se pot "proteja" pentru comanda <code class="stil_cmdBash">for</code> și eventualele caractere tab
ce ar putea apare în numele fișierelor și subdirectoarelor obținute cu comanda <code class="stil_cmdBash">ls -A</code>
(sau cu șabloanele <tt class="stil_cmdBash">*</tt> și <tt class="stil_cmdBash">.*</tt> ).
</div>
</div>

</div>
<br><br>
</li>




<li><!-- Problema: lab5_ex5.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyFind #2]</span>
<br>Să se scrie un script care calculează numărul total de linii de text și respectiv de caractere din toate fișierele normale dintr-un director dat,
<u>parcurgand directorul respectiv în manieră recursivă, în mod explicit</u>
(i.e. fără a apela comanda <code>find</code> sau comanda <code>ls -R</code>).
Numele directorului se transmite ca parametru în linia de comandă, sau se va citi prin comanda read în caz contrar.
<br>
<small>(Indicație: <span class="stil_hint2">parcurgeți cu un for directorul curent și calculați informațiile solicitate, iar pentru
fiecare intrare din director care este de tipul (sub)director apelați recursiv scriptul.</span>)</small>
<br>
<i>Cerință suplimentară</i>: să se afișeze acele informații totale pentru fiecare subdirector parcurs.
</p>

<button onclick="myToggle('lab5_ex5')">Show / Hide a possible solution</button>

<div id="lab5_ex5" class="stil_rezolvare">
Exercițiul se rezolvă similar cu cel precedent, parcurgerea recursivă a subarborelui de fișiere se poate face prin oricare
dintre cele 4 metode ilustrate mai sus, doar statisticile calculate sunt diferite.
<br>
Vom ilustra în continuare doar prima variantă de rezolvare de la exercițiul precedent, adaptată pentru calculele cerute la acest exercițiu:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_2.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_2.sh">here</a>.</div>
</pre>
<p>
<i>Observație</i>: se poate rafina enunțul problemei, în sensul de a lua în calcul doar fișierele text, nu și cele binare.
În acest caz, se poate folosi comanda <code>file</code> pentru a depista care dintre fișiere sunt binare și respectiv care sunt fișiere text.
</p>
</div>
<br><br>
</li>



<li><!-- Problema: lab5_ex6.sh ------------------------------------------------------------------------------------------->
<p><span class="stil_titlu_ex">[MyFind #3]</span>
<br>Să se scrie un script care să afișeze un arbore cu structura subdirectoarelor din contul personal de pe server.
Parcurgerea recursivă a directorului <i>acasă</i> asociat contului personal de pe server,
se va face în manieră explicită (i.e. fără a apela comanda <code>find</code> sau comanda <code>ls -R</code>).
<br>
<i>Cerință suplimentară</i>: mai general, să se afișeze un arbore cu structura subdirectoarelor dintr-un director specificat ca argument.
</p>

<button onclick="myToggle('lab5_ex6')">Show / Hide a possible solution</button>

<div id="lab5_ex6" class="stil_rezolvare">
Exercițiul se rezolvă similar cu cele două precedente, parcurgerea recursivă a subarborelui de fișiere se poate face prin oricare
dintre cele 4 metode ilustrate mai sus, doar informațiile afișate sunt diferite.
<br>
Vom ilustra în continuare doar prima variantă de rezolvare de la exercițiile precedente, adaptată pentru cerințele acestui exercițiu:
<pre class="stil_codBash">
<div w3-include-MyCode="demo/lab5/MyFind_3.sh">See the script from <a target="_blank" href="demo/lab5/MyFind_3.sh">here</a>.</div>
</pre>
</div>
<br><br>
</li>

</ol>



<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
<hr style="border-top:3px solid darkblue;">
<script src="../js/script_toggle.js"></script>
<script>includeMyCode();</script>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
</body>
</html>
